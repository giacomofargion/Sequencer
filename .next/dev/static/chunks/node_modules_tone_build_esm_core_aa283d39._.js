(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Test if the arg is undefined
 */ __turbopack_context__.s([
    "isArray",
    ()=>isArray,
    "isBoolean",
    ()=>isBoolean,
    "isDefined",
    ()=>isDefined,
    "isFunction",
    ()=>isFunction,
    "isNote",
    ()=>isNote,
    "isNumber",
    ()=>isNumber,
    "isObject",
    ()=>isObject,
    "isString",
    ()=>isString,
    "isUndef",
    ()=>isUndef
]);
function isUndef(arg) {
    return arg === undefined;
}
function isDefined(arg) {
    return arg !== undefined;
}
function isFunction(arg) {
    return typeof arg === "function";
}
function isNumber(arg) {
    return typeof arg === "number";
}
function isObject(arg) {
    return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
}
function isBoolean(arg) {
    return typeof arg === "boolean";
}
function isArray(arg) {
    return Array.isArray(arg);
}
function isString(arg) {
    return typeof arg === "string";
}
function isNote(arg) {
    return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
} //# sourceMappingURL=TypeCheck.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "assert",
    ()=>assert,
    "assertContextRunning",
    ()=>assertContextRunning,
    "assertRange",
    ()=>assertRange,
    "assertUsedScheduleTime",
    ()=>assertUsedScheduleTime,
    "enterScheduledCallback",
    ()=>enterScheduledCallback,
    "log",
    ()=>log,
    "setLogger",
    ()=>setLogger,
    "warn",
    ()=>warn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
function assert(statement, error) {
    if (!statement) {
        throw new Error(error);
    }
}
function assertRange(value, gte, lte = Infinity) {
    if (!(gte <= value && value <= lte)) {
        throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
    }
}
function assertContextRunning(context) {
    // add a warning if the context is not started
    if (!context.isOffline && context.state !== "running") {
        warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
    }
}
/**
 * If it is currently inside a scheduled callback
 */ let isInsideScheduledCallback = false;
let printedScheduledWarning = false;
function enterScheduledCallback(insideCallback) {
    isInsideScheduledCallback = insideCallback;
}
function assertUsedScheduleTime(time) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(time) && isInsideScheduledCallback && !printedScheduledWarning) {
        printedScheduledWarning = true;
        warn("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing");
    }
}
/**
 * The default logger is the console
 */ let defaultLogger = console;
function setLogger(logger) {
    defaultLogger = logger;
}
function log(...args) {
    defaultLogger.log(...args);
}
function warn(...args) {
    defaultLogger.warn(...args);
} //# sourceMappingURL=Debug.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/AudioContext.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createAudioContext",
    ()=>createAudioContext,
    "createAudioWorkletNode",
    ()=>createAudioWorkletNode,
    "createOfflineAudioContext",
    ()=>createOfflineAudioContext,
    "hasAudioContext",
    ()=>hasAudioContext,
    "theWindow",
    ()=>theWindow
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/standardized-audio-context/build/es2019/module.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
;
function createAudioContext(options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AudioContext"](options);
}
function createOfflineAudioContext(channels, length, sampleRate) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["OfflineAudioContext"](channels, length, sampleRate);
}
const theWindow = typeof self === "object" ? self : null;
const hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
function createAudioWorkletNode(context, name, options) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AudioWorkletNode"]), "AudioWorkletNode only works in a secure context (https or localhost)");
    return new (context instanceof (theWindow === null || theWindow === void 0 ? void 0 : theWindow.BaseAudioContext) ? theWindow === null || theWindow === void 0 ? void 0 : theWindow.AudioWorkletNode : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AudioWorkletNode"])(context, name, options);
}
;
 //# sourceMappingURL=AudioContext.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/Ticker.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A class which provides a reliable callback using either
 * a Web Worker, or if that isn't supported, falls back to setTimeout.
 */ __turbopack_context__.s([
    "Ticker",
    ()=>Ticker
]);
class Ticker {
    constructor(callback, type, updateInterval, contextSampleRate){
        this._callback = callback;
        this._type = type;
        this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 0.001);
        this.updateInterval = updateInterval;
        // create the clock source for the first time
        this._createClock();
    }
    /**
     * Generate a web worker
     */ _createWorker() {
        const blob = new Blob([
            /* javascript */ `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
        ], {
            type: "text/javascript"
        });
        const blobUrl = URL.createObjectURL(blob);
        const worker = new Worker(blobUrl);
        worker.onmessage = this._callback.bind(this);
        this._worker = worker;
    }
    /**
     * Create a timeout loop
     */ _createTimeout() {
        this._timeout = setTimeout(()=>{
            this._createTimeout();
            this._callback();
        }, this._updateInterval * 1000);
    }
    /**
     * Create the clock source.
     */ _createClock() {
        if (this._type === "worker") {
            try {
                this._createWorker();
            } catch (e) {
                // workers not supported, fallback to timeout
                this._type = "timeout";
                this._createClock();
            }
        } else if (this._type === "timeout") {
            this._createTimeout();
        }
    }
    /**
     * Clean up the current clock source
     */ _disposeClock() {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        if (this._worker) {
            this._worker.terminate();
            this._worker.onmessage = null;
        }
    }
    /**
     * The rate in seconds the ticker will update
     */ get updateInterval() {
        return this._updateInterval;
    }
    set updateInterval(interval) {
        var _a;
        this._updateInterval = Math.max(interval, this._minimumUpdateInterval);
        if (this._type === "worker") {
            (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(this._updateInterval * 1000);
        }
    }
    /**
     * The type of the ticker, either a worker or a timeout
     */ get type() {
        return this._type;
    }
    set type(type) {
        this._disposeClock();
        this._type = type;
        this._createClock();
    }
    /**
     * Clean up
     */ dispose() {
        this._disposeClock();
    }
} //# sourceMappingURL=Ticker.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isAudioBuffer",
    ()=>isAudioBuffer,
    "isAudioContext",
    ()=>isAudioContext,
    "isAudioNode",
    ()=>isAudioNode,
    "isAudioParam",
    ()=>isAudioParam,
    "isOfflineAudioContext",
    ()=>isOfflineAudioContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/standardized-audio-context/build/es2019/module.js [app-client] (ecmascript) <locals>");
;
function isAudioParam(arg) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyAudioParam"])(arg);
}
function isAudioNode(arg) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyAudioNode"])(arg);
}
function isOfflineAudioContext(arg) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyOfflineAudioContext"])(arg);
}
function isAudioContext(arg) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyAudioContext"])(arg);
}
function isAudioBuffer(arg) {
    return arg instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$standardized$2d$audio$2d$context$2f$build$2f$es2019$2f$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["AudioBuffer"];
} //# sourceMappingURL=AdvancedTypeCheck.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deepEquals",
    ()=>deepEquals,
    "deepMerge",
    ()=>deepMerge,
    "defaultArg",
    ()=>defaultArg,
    "getDefaultsFromInstance",
    ()=>getDefaultsFromInstance,
    "omitFromObject",
    ()=>omitFromObject,
    "optionsFromArguments",
    ()=>optionsFromArguments
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
/**
 * Some objects should not be merged
 */ function noCopy(key, arg) {
    return key === "value" || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(arg) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(arg) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioBuffer"])(arg);
}
function deepMerge(target, ...sources) {
    if (!sources.length) {
        return target;
    }
    const source = sources.shift();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(target) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(source)) {
        for(const key in source){
            if (noCopy(key, source[key])) {
                target[key] = source[key];
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(source[key])) {
                if (!target[key]) {
                    Object.assign(target, {
                        [key]: {}
                    });
                }
                deepMerge(target[key], source[key]);
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
        }
    }
    // @ts-ignore
    return deepMerge(target, ...sources);
}
function deepEquals(arrayA, arrayB) {
    return arrayA.length === arrayB.length && arrayA.every((element, index)=>arrayB[index] === element);
}
function optionsFromArguments(defaults, argsArray, keys = [], objKey) {
    const opts = {};
    const args = Array.from(argsArray);
    // if the first argument is an object and has an object key
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
        // if it's not part of the defaults
        const partOfDefaults = Object.keys(args[0]).some((key)=>Reflect.has(defaults, key));
        if (!partOfDefaults) {
            // merge that key
            deepMerge(opts, {
                [objKey]: args[0]
            });
            // remove the obj key from the keys
            keys.splice(keys.indexOf(objKey), 1);
            // shift the first argument off
            args.shift();
        }
    }
    if (args.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(args[0])) {
        deepMerge(opts, args[0]);
    } else {
        for(let i = 0; i < keys.length; i++){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(args[i])) {
                opts[keys[i]] = args[i];
            }
        }
    }
    return deepMerge(defaults, opts);
}
function getDefaultsFromInstance(instance) {
    return instance.constructor.getDefaults();
}
function defaultArg(given, fallback) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(given)) {
        return fallback;
    } else {
        return given;
    }
}
function omitFromObject(obj, omit) {
    omit.forEach((prop)=>{
        if (Reflect.has(obj, prop)) {
            delete obj[prop];
        }
    });
    return obj;
} //# sourceMappingURL=Defaults.js.map
}),
"[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2024 Yotam Mann
 */ __turbopack_context__.s([
    "Tone",
    ()=>Tone
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/AudioContext.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
class Tone {
    constructor(){
        //-------------------------------------
        // 	DEBUGGING
        //-------------------------------------
        /**
         * Set this debug flag to log all events that happen in this class.
         */ this.debug = false;
        //-------------------------------------
        // 	DISPOSING
        //-------------------------------------
        /**
         * Indicates if the instance was disposed
         */ this._wasDisposed = false;
    }
    /**
     * Returns all of the default options belonging to the class.
     */ static getDefaults() {
        return {};
    }
    /**
     * Prints the outputs to the console log for debugging purposes.
     * Prints the contents only if either the object has a property
     * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
     * is set to the name of the class.
     * @example
     * const osc = new Tone.Oscillator();
     * // prints all logs originating from this oscillator
     * osc.debug = true;
     * // calls to start/stop will print in the console
     * osc.start();
     */ log(...args) {
        // if the object is either set to debug = true
        // or if there is a string on the Tone.global.with the class name
        if (this.debug || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["theWindow"] && this.toString() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["theWindow"].TONE_DEBUG_CLASS) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log"])(this, ...args);
        }
    }
    /**
     * disconnect and dispose.
     */ dispose() {
        this._wasDisposed = true;
        return this;
    }
    /**
     * Indicates if the instance was disposed. 'Disposing' an
     * instance means that all of the Web Audio nodes that were
     * created for the instance are disconnected and freed for garbage collection.
     */ get disposed() {
        return this._wasDisposed;
    }
    /**
     * Convert the class to a string
     * @example
     * const osc = new Tone.Oscillator();
     * console.log(osc.toString());
     */ toString() {
        return this.name;
    }
}
/**
 * The version number semver
 */ Tone.version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]; //# sourceMappingURL=Tone.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Math.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * The threshold for correctness for operators. Less than one sample even
 * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).
 */ __turbopack_context__.s([
    "EQ",
    ()=>EQ,
    "GT",
    ()=>GT,
    "GTE",
    ()=>GTE,
    "LT",
    ()=>LT,
    "clamp",
    ()=>clamp
]);
const EPSILON = 1e-6;
function GT(a, b) {
    return a > b + EPSILON;
}
function GTE(a, b) {
    return GT(a, b) || EQ(a, b);
}
function LT(a, b) {
    return a + EPSILON < b;
}
function EQ(a, b) {
    return Math.abs(a - b) < EPSILON;
}
function clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
} //# sourceMappingURL=Math.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Timeline",
    ()=>Timeline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Math.js [app-client] (ecmascript)");
;
;
;
;
class Timeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super();
        this.name = "Timeline";
        /**
         * The array of scheduled timeline events
         */ this._timeline = [];
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Timeline.getDefaults(), arguments, [
            "memory"
        ]);
        this.memory = options.memory;
        this.increasing = options.increasing;
    }
    static getDefaults() {
        return {
            memory: Infinity,
            increasing: false
        };
    }
    /**
     * The number of items in the timeline.
     */ get length() {
        return this._timeline.length;
    }
    /**
     * Insert an event object onto the timeline. Events must have a "time" attribute.
     * @param event  The event object to insert into the timeline.
     */ add(event) {
        // the event needs to have a time attribute
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
        event.time = event.time.valueOf();
        if (this.increasing && this.length) {
            const lastValue = this._timeline[this.length - 1];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GTE"])(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
            this._timeline.push(event);
        } else {
            const index = this._search(event.time);
            this._timeline.splice(index + 1, 0, event);
        }
        // if the length is more than the memory, remove the previous ones
        if (this.length > this.memory) {
            const diff = this.length - this.memory;
            this._timeline.splice(0, diff);
        }
        return this;
    }
    /**
     * Remove an event from the timeline.
     * @param  {Object}  event  The event object to remove from the list.
     * @returns {Timeline} this
     */ remove(event) {
        const index = this._timeline.indexOf(event);
        if (index !== -1) {
            this._timeline.splice(index, 1);
        }
        return this;
    }
    /**
     * Get the nearest event whose time is less than or equal to the given time.
     * @param  time  The time to query.
     */ get(time, param = "time") {
        const index = this._search(time, param);
        if (index !== -1) {
            return this._timeline[index];
        } else {
            return null;
        }
    }
    /**
     * Return the first event in the timeline without removing it
     * @returns {Object} The first event object
     * @deprecated
     */ peek() {
        return this._timeline[0];
    }
    /**
     * Return the first event in the timeline and remove it
     * @deprecated
     */ shift() {
        return this._timeline.shift();
    }
    /**
     * Get the event which is scheduled after the given time.
     * @param  time  The time to query.
     */ getAfter(time, param = "time") {
        const index = this._search(time, param);
        if (index + 1 < this._timeline.length) {
            return this._timeline[index + 1];
        } else {
            return null;
        }
    }
    /**
     * Get the event before the event at the given time.
     * @param  time  The time to query.
     */ getBefore(time) {
        const len = this._timeline.length;
        // if it's after the last item, return the last item
        if (len > 0 && this._timeline[len - 1].time < time) {
            return this._timeline[len - 1];
        }
        const index = this._search(time);
        if (index - 1 >= 0) {
            return this._timeline[index - 1];
        } else {
            return null;
        }
    }
    /**
     * Cancel events at and after the given time
     * @param  after  The time to query.
     */ cancel(after) {
        if (this._timeline.length > 1) {
            let index = this._search(after);
            if (index >= 0) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(this._timeline[index].time, after)) {
                    // get the first item with that time
                    for(let i = index; i >= 0; i--){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(this._timeline[i].time, after)) {
                            index = i;
                        } else {
                            break;
                        }
                    }
                    this._timeline = this._timeline.slice(0, index);
                } else {
                    this._timeline = this._timeline.slice(0, index + 1);
                }
            } else {
                this._timeline = [];
            }
        } else if (this._timeline.length === 1) {
            // the first item's time
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GTE"])(this._timeline[0].time, after)) {
                this._timeline = [];
            }
        }
        return this;
    }
    /**
     * Cancel events before or equal to the given time.
     * @param  time  The time to cancel before.
     */ cancelBefore(time) {
        const index = this._search(time);
        if (index >= 0) {
            this._timeline = this._timeline.slice(index + 1);
        }
        return this;
    }
    /**
     * Returns the previous event if there is one. null otherwise
     * @param  event The event to find the previous one of
     * @return The event right before the given event
     */ previousEvent(event) {
        const index = this._timeline.indexOf(event);
        if (index > 0) {
            return this._timeline[index - 1];
        } else {
            return null;
        }
    }
    /**
     * Does a binary search on the timeline array and returns the
     * nearest event index whose time is after or equal to the given time.
     * If a time is searched before the first index in the timeline, -1 is returned.
     * If the time is after the end, the index of the last item is returned.
     */ _search(time, param = "time") {
        if (this._timeline.length === 0) {
            return -1;
        }
        let beginning = 0;
        const len = this._timeline.length;
        let end = len;
        if (len > 0 && this._timeline[len - 1][param] <= time) {
            return len - 1;
        }
        while(beginning < end){
            // calculate the midpoint for roughly equal partition
            let midPoint = Math.floor(beginning + (end - beginning) / 2);
            const event = this._timeline[midPoint];
            const nextEvent = this._timeline[midPoint + 1];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(event[param], time)) {
                // choose the last one that has the same time
                for(let i = midPoint; i < this._timeline.length; i++){
                    const testEvent = this._timeline[i];
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(testEvent[param], time)) {
                        midPoint = i;
                    } else {
                        break;
                    }
                }
                return midPoint;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LT"])(event[param], time) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GT"])(nextEvent[param], time)) {
                return midPoint;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GT"])(event[param], time)) {
                // search lower
                end = midPoint;
            } else {
                // search upper
                beginning = midPoint + 1;
            }
        }
        return -1;
    }
    /**
     * Internal iterator. Applies extra safety checks for
     * removing items from the array.
     */ _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
        this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
    }
    /**
     * Iterate over everything in the array
     * @param  callback The callback to invoke with every item
     */ forEach(callback) {
        this._iterate(callback);
        return this;
    }
    /**
     * Iterate over everything in the array at or before the given time.
     * @param  time The time to check if items are before
     * @param  callback The callback to invoke with every item
     */ forEachBefore(time, callback) {
        // iterate over the items in reverse so that removing an item doesn't break things
        const upperBound = this._search(time);
        if (upperBound !== -1) {
            this._iterate(callback, 0, upperBound);
        }
        return this;
    }
    /**
     * Iterate over everything in the array after the given time.
     * @param  time The time to check if items are before
     * @param  callback The callback to invoke with every item
     */ forEachAfter(time, callback) {
        // iterate over the items in reverse so that removing an item doesn't break things
        const lowerBound = this._search(time);
        this._iterate(callback, lowerBound + 1);
        return this;
    }
    /**
     * Iterate over everything in the array between the startTime and endTime.
     * The timerange is inclusive of the startTime, but exclusive of the endTime.
     * range = [startTime, endTime).
     * @param  startTime The time to check if items are before
     * @param  endTime The end of the test interval.
     * @param  callback The callback to invoke with every item
     */ forEachBetween(startTime, endTime, callback) {
        let lowerBound = this._search(startTime);
        let upperBound = this._search(endTime);
        if (lowerBound !== -1 && upperBound !== -1) {
            if (this._timeline[lowerBound].time !== startTime) {
                lowerBound += 1;
            }
            // exclusive of the end time
            if (this._timeline[upperBound].time === endTime) {
                upperBound -= 1;
            }
            this._iterate(callback, lowerBound, upperBound);
        } else if (lowerBound === -1) {
            this._iterate(callback, 0, upperBound);
        }
        return this;
    }
    /**
     * Iterate over everything in the array at or after the given time. Similar to
     * forEachAfter, but includes the item(s) at the given time.
     * @param  time The time to check if items are before
     * @param  callback The callback to invoke with every item
     */ forEachFrom(time, callback) {
        // iterate over the items in reverse so that removing an item doesn't break things
        let lowerBound = this._search(time);
        // work backwards until the event time is less than time
        while(lowerBound >= 0 && this._timeline[lowerBound].time >= time){
            lowerBound--;
        }
        this._iterate(callback, lowerBound + 1);
        return this;
    }
    /**
     * Iterate over everything in the array at the given time
     * @param  time The time to check if items are before
     * @param  callback The callback to invoke with every item
     */ forEachAtTime(time, callback) {
        // iterate over the items in reverse so that removing an item doesn't break things
        const upperBound = this._search(time);
        if (upperBound !== -1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(this._timeline[upperBound].time, time)) {
            let lowerBound = upperBound;
            for(let i = upperBound; i >= 0; i--){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(this._timeline[i].time, time)) {
                    lowerBound = i;
                } else {
                    break;
                }
            }
            this._iterate((event)=>{
                callback(event);
            }, lowerBound, upperBound);
        }
        return this;
    }
    /**
     * Clean up.
     */ dispose() {
        super.dispose();
        this._timeline = [];
        return this;
    }
} //# sourceMappingURL=Timeline.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Array of callbacks to invoke when a new context is created
 */ __turbopack_context__.s([
    "closeContext",
    ()=>closeContext,
    "initializeContext",
    ()=>initializeContext,
    "onContextClose",
    ()=>onContextClose,
    "onContextInit",
    ()=>onContextInit
]);
const notifyNewContext = [];
function onContextInit(cb) {
    notifyNewContext.push(cb);
}
function initializeContext(ctx) {
    // add any additional modules
    notifyNewContext.forEach((cb)=>cb(ctx));
}
/**
 * Array of callbacks to invoke when a new context is closed
 */ const notifyCloseContext = [];
function onContextClose(cb) {
    notifyCloseContext.push(cb);
}
function closeContext(ctx) {
    // remove any additional modules
    notifyCloseContext.forEach((cb)=>cb(ctx));
} //# sourceMappingURL=ContextInitialization.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Emitter",
    ()=>Emitter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
class Emitter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super(...arguments);
        this.name = "Emitter";
    }
    /**
     * Bind a callback to a specific event.
     * @param  event     The name of the event to listen for.
     * @param  callback  The callback to invoke when the event is emitted
     */ on(event, callback) {
        // split the event
        const events = event.split(/\W+/);
        events.forEach((eventName)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(this._events)) {
                this._events = {};
            }
            if (!this._events.hasOwnProperty(eventName)) {
                this._events[eventName] = [];
            }
            this._events[eventName].push(callback);
        });
        return this;
    }
    /**
     * Bind a callback which is only invoked once
     * @param  event     The name of the event to listen for.
     * @param  callback  The callback to invoke when the event is emitted
     */ once(event, callback) {
        const boundCallback = (...args)=>{
            // invoke the callback
            callback(...args);
            // remove the event
            this.off(event, boundCallback);
        };
        this.on(event, boundCallback);
        return this;
    }
    /**
     * Remove the event listener.
     * @param  event     The event to stop listening to.
     * @param  callback  The callback which was bound to the event with Emitter.on.
     *                   If no callback is given, all callbacks events are removed.
     */ off(event, callback) {
        const events = event.split(/\W+/);
        events.forEach((eventName)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(this._events)) {
                this._events = {};
            }
            if (this._events.hasOwnProperty(eventName)) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(callback)) {
                    this._events[eventName] = [];
                } else {
                    const eventList = this._events[eventName];
                    for(let i = eventList.length - 1; i >= 0; i--){
                        if (eventList[i] === callback) {
                            eventList.splice(i, 1);
                        }
                    }
                }
            }
        });
        return this;
    }
    /**
     * Invoke all of the callbacks bound to the event
     * with any arguments passed in.
     * @param  event  The name of the event.
     * @param args The arguments to pass to the functions listening.
     */ emit(event, ...args) {
        if (this._events) {
            if (this._events.hasOwnProperty(event)) {
                const eventList = this._events[event].slice(0);
                for(let i = 0, len = eventList.length; i < len; i++){
                    eventList[i].apply(this, args);
                }
            }
        }
        return this;
    }
    /**
     * Add Emitter functions (on/off/emit) to the object
     */ static mixin(constr) {
        // instance._events = {};
        [
            "on",
            "once",
            "off",
            "emit"
        ].forEach((name)=>{
            const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);
            Object.defineProperty(constr.prototype, name, property);
        });
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        this._events = undefined;
        return this;
    }
} //# sourceMappingURL=Emitter.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/BaseContext.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseContext",
    ()=>BaseContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)");
;
class BaseContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Emitter"] {
    constructor(){
        super(...arguments);
        this.isOffline = false;
    }
    /*
     * This is a placeholder so that JSON.stringify does not throw an error
     * This matches what JSON.stringify(audioContext) returns on a native
     * audioContext instance.
     */ toJSON() {
        return {};
    }
} //# sourceMappingURL=BaseContext.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Context.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Context",
    ()=>Context
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Ticker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/Ticker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/AudioContext.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/BaseContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
class Context extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseContext"] {
    constructor(){
        var _a, _b;
        super();
        this.name = "Context";
        /**
         * An object containing all of the constants AudioBufferSourceNodes
         */ this._constants = new Map();
        /**
         * All of the setTimeout events.
         */ this._timeouts = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        /**
         * The timeout id counter
         */ this._timeoutIds = 0;
        /**
         * Private indicator if the context has been initialized
         */ this._initialized = false;
        /**
         * Private indicator if a close() has been called on the context, since close is async
         */ this._closeStarted = false;
        /**
         * Indicates if the context is an OfflineAudioContext or an AudioContext
         */ this.isOffline = false;
        //--------------------------------------------
        // AUDIO WORKLET
        //--------------------------------------------
        /**
         * Maps a module name to promise of the addModule method
         */ this._workletPromise = null;
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Context.getDefaults(), arguments, [
            "context"
        ]);
        if (options.context) {
            this._context = options.context;
            // custom context provided, latencyHint unknown (unless explicitly provided in options)
            this._latencyHint = ((_a = arguments[0]) === null || _a === void 0 ? void 0 : _a.latencyHint) || "";
        } else {
            this._context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAudioContext"])({
                latencyHint: options.latencyHint
            });
            this._latencyHint = options.latencyHint;
        }
        this._ticker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Ticker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticker"](this.emit.bind(this, "tick"), options.clockSource, options.updateInterval, this._context.sampleRate);
        this.on("tick", this._timeoutLoop.bind(this));
        // fwd events from the context
        this._context.onstatechange = ()=>{
            this.emit("statechange", this.state);
        };
        // if no custom updateInterval provided, updateInterval will be derived by lookAhead setter
        this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("updateInterval")) ? "_lookAhead" : "lookAhead"] = options.lookAhead;
    }
    static getDefaults() {
        return {
            clockSource: "worker",
            latencyHint: "interactive",
            lookAhead: 0.1,
            updateInterval: 0.05
        };
    }
    /**
     * Finish setting up the context. **You usually do not need to do this manually.**
     */ initialize() {
        if (!this._initialized) {
            // add any additional modules
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeContext"])(this);
            this._initialized = true;
        }
        return this;
    }
    //---------------------------
    // BASE AUDIO CONTEXT METHODS
    //---------------------------
    createAnalyser() {
        return this._context.createAnalyser();
    }
    createOscillator() {
        return this._context.createOscillator();
    }
    createBufferSource() {
        return this._context.createBufferSource();
    }
    createBiquadFilter() {
        return this._context.createBiquadFilter();
    }
    createBuffer(numberOfChannels, length, sampleRate) {
        return this._context.createBuffer(numberOfChannels, length, sampleRate);
    }
    createChannelMerger(numberOfInputs) {
        return this._context.createChannelMerger(numberOfInputs);
    }
    createChannelSplitter(numberOfOutputs) {
        return this._context.createChannelSplitter(numberOfOutputs);
    }
    createConstantSource() {
        return this._context.createConstantSource();
    }
    createConvolver() {
        return this._context.createConvolver();
    }
    createDelay(maxDelayTime) {
        return this._context.createDelay(maxDelayTime);
    }
    createDynamicsCompressor() {
        return this._context.createDynamicsCompressor();
    }
    createGain() {
        return this._context.createGain();
    }
    createIIRFilter(feedForward, feedback) {
        // @ts-ignore
        return this._context.createIIRFilter(feedForward, feedback);
    }
    createPanner() {
        return this._context.createPanner();
    }
    createPeriodicWave(real, imag, constraints) {
        return this._context.createPeriodicWave(real, imag, constraints);
    }
    createStereoPanner() {
        return this._context.createStereoPanner();
    }
    createWaveShaper() {
        return this._context.createWaveShaper();
    }
    createMediaStreamSource(stream) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(this._context), "Not available if OfflineAudioContext");
        const context = this._context;
        return context.createMediaStreamSource(stream);
    }
    createMediaElementSource(element) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(this._context), "Not available if OfflineAudioContext");
        const context = this._context;
        return context.createMediaElementSource(element);
    }
    createMediaStreamDestination() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(this._context), "Not available if OfflineAudioContext");
        const context = this._context;
        return context.createMediaStreamDestination();
    }
    decodeAudioData(audioData) {
        return this._context.decodeAudioData(audioData);
    }
    /**
     * The current time in seconds of the AudioContext.
     */ get currentTime() {
        return this._context.currentTime;
    }
    /**
     * The current time in seconds of the AudioContext.
     */ get state() {
        return this._context.state;
    }
    /**
     * The current time in seconds of the AudioContext.
     */ get sampleRate() {
        return this._context.sampleRate;
    }
    /**
     * The listener
     */ get listener() {
        this.initialize();
        return this._listener;
    }
    set listener(l) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this._initialized, "The listener cannot be set after initialization.");
        this._listener = l;
    }
    /**
     * There is only one Transport per Context. It is created on initialization.
     */ get transport() {
        this.initialize();
        return this._transport;
    }
    set transport(t) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this._initialized, "The transport cannot be set after initialization.");
        this._transport = t;
    }
    /**
     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
     */ get draw() {
        this.initialize();
        return this._draw;
    }
    set draw(d) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this._initialized, "Draw cannot be set after initialization.");
        this._draw = d;
    }
    /**
     * A reference to the Context's destination node.
     */ get destination() {
        this.initialize();
        return this._destination;
    }
    set destination(d) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this._initialized, "The destination cannot be set after initialization.");
        this._destination = d;
    }
    /**
     * Create an audio worklet node from a name and options. The module
     * must first be loaded using {@link addAudioWorkletModule}.
     */ createAudioWorkletNode(name, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAudioWorkletNode"])(this.rawContext, name, options);
    }
    /**
     * Add an AudioWorkletProcessor module
     * @param url The url of the module
     */ addAudioWorkletModule(url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
            if (!this._workletPromise) {
                this._workletPromise = this.rawContext.audioWorklet.addModule(url);
            }
            yield this._workletPromise;
        });
    }
    /**
     * Returns a promise which resolves when all of the worklets have been loaded on this context
     */ workletsAreReady() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
        });
    }
    //---------------------------
    // TICKER
    //---------------------------
    /**
     * How often the interval callback is invoked.
     * This number corresponds to how responsive the scheduling
     * can be. Setting to 0 will result in the lowest practial interval
     * based on context properties. context.updateInterval + context.lookAhead
     * gives you the total latency between scheduling an event and hearing it.
     */ get updateInterval() {
        return this._ticker.updateInterval;
    }
    set updateInterval(interval) {
        this._ticker.updateInterval = interval;
    }
    /**
     * What the source of the clock is, either "worker" (default),
     * "timeout", or "offline" (none).
     */ get clockSource() {
        return this._ticker.type;
    }
    set clockSource(type) {
        this._ticker.type = type;
    }
    /**
     * The amount of time into the future events are scheduled. Giving Web Audio
     * a short amount of time into the future to schedule events can reduce clicks and
     * improve performance. This value can be set to 0 to get the lowest latency.
     * Adjusting this value also affects the {@link updateInterval}.
     */ get lookAhead() {
        return this._lookAhead;
    }
    set lookAhead(time) {
        this._lookAhead = time;
        // if lookAhead is 0, default to .01 updateInterval
        this.updateInterval = time ? time / 2 : 0.01;
    }
    /**
     * The type of playback, which affects tradeoffs between audio
     * output latency and responsiveness.
     * In addition to setting the value in seconds, the latencyHint also
     * accepts the strings "interactive" (prioritizes low latency),
     * "playback" (prioritizes sustained playback), "balanced" (balances
     * latency and performance).
     * @example
     * // prioritize sustained playback
     * const context = new Tone.Context({ latencyHint: "playback" });
     * // set this context as the global Context
     * Tone.setContext(context);
     * // the global context is gettable with Tone.getContext()
     * console.log(Tone.getContext().latencyHint);
     */ get latencyHint() {
        return this._latencyHint;
    }
    /**
     * The unwrapped AudioContext or OfflineAudioContext
     */ get rawContext() {
        return this._context;
    }
    /**
     * The current audio context time plus a short {@link lookAhead}.
     * @example
     * setInterval(() => {
     * 	console.log("now", Tone.now());
     * }, 100);
     */ now() {
        return this._context.currentTime + this._lookAhead;
    }
    /**
     * The current audio context time without the {@link lookAhead}.
     * In most cases it is better to use {@link now} instead of {@link immediate} since
     * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
     * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
     * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
     */ immediate() {
        return this._context.currentTime;
    }
    /**
     * Starts the audio context from a suspended state. This is required
     * to initially start the AudioContext.
     * @see {@link start}
     */ resume() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(this._context)) {
            return this._context.resume();
        } else {
            return Promise.resolve();
        }
    }
    /**
     * Close the context. Once closed, the context can no longer be used and
     * any AudioNodes created from the context will be silent.
     */ close() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(this._context) && this.state !== "closed" && !this._closeStarted) {
                this._closeStarted = true;
                yield this._context.close();
            }
            if (this._initialized) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["closeContext"])(this);
            }
        });
    }
    /**
     * **Internal** Generate a looped buffer at some constant value.
     */ getConstant(val) {
        if (this._constants.has(val)) {
            return this._constants.get(val);
        } else {
            const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
            const arr = buffer.getChannelData(0);
            for(let i = 0; i < arr.length; i++){
                arr[i] = val;
            }
            const constant = this._context.createBufferSource();
            constant.channelCount = 1;
            constant.channelCountMode = "explicit";
            constant.buffer = buffer;
            constant.loop = true;
            constant.start(0);
            this._constants.set(val, constant);
            return constant;
        }
    }
    /**
     * Clean up. Also closes the audio context.
     */ dispose() {
        super.dispose();
        this._ticker.dispose();
        this._timeouts.dispose();
        Object.keys(this._constants).map((val)=>this._constants[val].disconnect());
        this.close();
        return this;
    }
    //---------------------------
    // TIMEOUTS
    //---------------------------
    /**
     * The private loop which keeps track of the context scheduled timeouts
     * Is invoked from the clock source
     */ _timeoutLoop() {
        const now = this.now();
        this._timeouts.forEachBefore(now, (event)=>{
            // invoke the callback
            event.callback();
            this._timeouts.remove(event);
        });
    }
    /**
     * A setTimeout which is guaranteed by the clock source.
     * Also runs in the offline context.
     * @param  fn       The callback to invoke
     * @param  timeout  The timeout in seconds
     * @returns ID to use when invoking Context.clearTimeout
     */ setTimeout(fn, timeout) {
        this._timeoutIds++;
        const now = this.now();
        this._timeouts.add({
            callback: fn,
            id: this._timeoutIds,
            time: now + timeout
        });
        return this._timeoutIds;
    }
    /**
     * Clears a previously scheduled timeout with Tone.context.setTimeout
     * @param  id  The ID returned from setTimeout
     */ clearTimeout(id) {
        this._timeouts.forEach((event)=>{
            if (event.id === id) {
                this._timeouts.remove(event);
            }
        });
        return this;
    }
    /**
     * Clear the function scheduled by {@link setInterval}
     */ clearInterval(id) {
        return this.clearTimeout(id);
    }
    /**
     * Adds a repeating event to the context's callback clock
     */ setInterval(fn, interval) {
        const id = ++this._timeoutIds;
        const intervalFn = ()=>{
            const now = this.now();
            this._timeouts.add({
                callback: ()=>{
                    // invoke the callback
                    fn();
                    // invoke the event to repeat it
                    intervalFn();
                },
                id,
                time: now + interval
            });
        };
        // kick it off
        intervalFn();
        return id;
    }
} //# sourceMappingURL=Context.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/DummyContext.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DummyContext",
    ()=>DummyContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/BaseContext.js [app-client] (ecmascript)");
;
;
class DummyContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseContext"] {
    constructor(){
        super(...arguments);
        this.lookAhead = 0;
        this.latencyHint = 0;
        this.isOffline = false;
    }
    //---------------------------
    // BASE AUDIO CONTEXT METHODS
    //---------------------------
    createAnalyser() {
        return {};
    }
    createOscillator() {
        return {};
    }
    createBufferSource() {
        return {};
    }
    createBiquadFilter() {
        return {};
    }
    createBuffer(_numberOfChannels, _length, _sampleRate) {
        return {};
    }
    createChannelMerger(_numberOfInputs) {
        return {};
    }
    createChannelSplitter(_numberOfOutputs) {
        return {};
    }
    createConstantSource() {
        return {};
    }
    createConvolver() {
        return {};
    }
    createDelay(_maxDelayTime) {
        return {};
    }
    createDynamicsCompressor() {
        return {};
    }
    createGain() {
        return {};
    }
    createIIRFilter(_feedForward, _feedback) {
        return {};
    }
    createPanner() {
        return {};
    }
    createPeriodicWave(_real, _imag, _constraints) {
        return {};
    }
    createStereoPanner() {
        return {};
    }
    createWaveShaper() {
        return {};
    }
    createMediaStreamSource(_stream) {
        return {};
    }
    createMediaElementSource(_element) {
        return {};
    }
    createMediaStreamDestination() {
        return {};
    }
    decodeAudioData(_audioData) {
        return Promise.resolve({});
    }
    //---------------------------
    // TONE AUDIO CONTEXT METHODS
    //---------------------------
    createAudioWorkletNode(_name, _options) {
        return {};
    }
    get rawContext() {
        return {};
    }
    addAudioWorkletModule(_url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            return Promise.resolve();
        });
    }
    resume() {
        return Promise.resolve();
    }
    setTimeout(_fn, _timeout) {
        return 0;
    }
    clearTimeout(_id) {
        return this;
    }
    setInterval(_fn, _interval) {
        return 0;
    }
    clearInterval(_id) {
        return this;
    }
    getConstant(_val) {
        return {};
    }
    get currentTime() {
        return 0;
    }
    get state() {
        return {};
    }
    get sampleRate() {
        return 0;
    }
    get listener() {
        return {};
    }
    get transport() {
        return {};
    }
    get draw() {
        return {};
    }
    set draw(_d) {}
    get destination() {
        return {};
    }
    set destination(_d) {}
    now() {
        return 0;
    }
    immediate() {
        return 0;
    }
} //# sourceMappingURL=DummyContext.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "noOp",
    ()=>noOp,
    "readOnly",
    ()=>readOnly,
    "writable",
    ()=>writable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
function readOnly(target, property) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(property)) {
        property.forEach((str)=>readOnly(target, str));
    } else {
        Object.defineProperty(target, property, {
            enumerable: true,
            writable: false
        });
    }
}
function writable(target, property) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(property)) {
        property.forEach((str)=>writable(target, str));
    } else {
        Object.defineProperty(target, property, {
            writable: true
        });
    }
}
const noOp = ()=>{
// no operation here!
}; //# sourceMappingURL=Interface.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToneAudioBuffer",
    ()=>ToneAudioBuffer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
class ToneAudioBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super();
        this.name = "ToneAudioBuffer";
        /**
         * Callback when the buffer is loaded.
         */ this.onload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"];
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(ToneAudioBuffer.getDefaults(), arguments, [
            "url",
            "onload",
            "onerror"
        ]);
        this.reverse = options.reverse;
        this.onload = options.onload;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(options.url)) {
            // initiate the download
            this.load(options.url).catch(options.onerror);
        } else if (options.url) {
            this.set(options.url);
        }
    }
    static getDefaults() {
        return {
            onerror: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            onload: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            reverse: false
        };
    }
    /**
     * The sample rate of the AudioBuffer
     */ get sampleRate() {
        if (this._buffer) {
            return this._buffer.sampleRate;
        } else {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])().sampleRate;
        }
    }
    /**
     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
     */ set(buffer) {
        if (buffer instanceof ToneAudioBuffer) {
            // if it's loaded, set it
            if (buffer.loaded) {
                this._buffer = buffer.get();
            } else {
                // otherwise when it's loaded, invoke it's callback
                buffer.onload = ()=>{
                    this.set(buffer);
                    this.onload(this);
                };
            }
        } else {
            this._buffer = buffer;
        }
        // reverse it initially
        if (this._reversed) {
            this._reverse();
        }
        return this;
    }
    /**
     * The audio buffer stored in the object.
     */ get() {
        return this._buffer;
    }
    /**
     * Makes an fetch request for the selected url then decodes the file as an audio buffer.
     * Invokes the callback once the audio buffer loads.
     * @param url The url of the buffer to load. filetype support depends on the browser.
     * @returns A Promise which resolves with this ToneAudioBuffer
     */ load(url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer)=>{
                this.set(audioBuffer);
                // invoke the onload method
                this.onload(this);
            });
            ToneAudioBuffer.downloads.push(doneLoading);
            try {
                yield doneLoading;
            } finally{
                // remove the downloaded file
                const index = ToneAudioBuffer.downloads.indexOf(doneLoading);
                ToneAudioBuffer.downloads.splice(index, 1);
            }
            return this;
        });
    }
    /**
     * clean up
     */ dispose() {
        super.dispose();
        this._buffer = undefined;
        return this;
    }
    /**
     * Set the audio buffer from the array.
     * To create a multichannel AudioBuffer, pass in a multidimensional array.
     * @param array The array to fill the audio buffer
     */ fromArray(array) {
        const isMultidimensional = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(array) && array[0].length > 0;
        const channels = isMultidimensional ? array.length : 1;
        const len = isMultidimensional ? array[0].length : array.length;
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])();
        const buffer = context.createBuffer(channels, len, context.sampleRate);
        const multiChannelArray = !isMultidimensional && channels === 1 ? [
            array
        ] : array;
        for(let c = 0; c < channels; c++){
            buffer.copyToChannel(multiChannelArray[c], c);
        }
        this._buffer = buffer;
        return this;
    }
    /**
     * Sums multiple channels into 1 channel
     * @param chanNum Optionally only copy a single channel from the array.
     */ toMono(chanNum) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(chanNum)) {
            this.fromArray(this.toArray(chanNum));
        } else {
            let outputArray = new Float32Array(this.length);
            const numChannels = this.numberOfChannels;
            for(let channel = 0; channel < numChannels; channel++){
                const channelArray = this.toArray(channel);
                for(let i = 0; i < channelArray.length; i++){
                    outputArray[i] += channelArray[i];
                }
            }
            // divide by the number of channels
            outputArray = outputArray.map((sample)=>sample / numChannels);
            this.fromArray(outputArray);
        }
        return this;
    }
    /**
     * Get the buffer as an array. Single channel buffers will return a 1-dimensional
     * Float32Array, and multichannel buffers will return multidimensional arrays.
     * @param channel Optionally only copy a single channel from the array.
     */ toArray(channel) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(channel)) {
            return this.getChannelData(channel);
        } else if (this.numberOfChannels === 1) {
            return this.toArray(0);
        } else {
            const ret = [];
            for(let c = 0; c < this.numberOfChannels; c++){
                ret[c] = this.getChannelData(c);
            }
            return ret;
        }
    }
    /**
     * Returns the Float32Array representing the PCM audio data for the specific channel.
     * @param  channel  The channel number to return
     * @return The audio as a TypedArray
     */ getChannelData(channel) {
        if (this._buffer) {
            return this._buffer.getChannelData(channel);
        } else {
            return new Float32Array(0);
        }
    }
    /**
     * Cut a subsection of the array and return a buffer of the
     * subsection. Does not modify the original buffer
     * @param start The time to start the slice
     * @param end The end time to slice. If none is given will default to the end of the buffer
     */ slice(start, end = this.duration) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this.loaded, "Buffer is not loaded");
        const startSamples = Math.floor(start * this.sampleRate);
        const endSamples = Math.floor(end * this.sampleRate);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(startSamples < endSamples, "The start time must be less than the end time");
        const length = endSamples - startSamples;
        const retBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])().createBuffer(this.numberOfChannels, length, this.sampleRate);
        for(let channel = 0; channel < this.numberOfChannels; channel++){
            retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
        }
        return new ToneAudioBuffer(retBuffer);
    }
    /**
     * Reverse the buffer.
     */ _reverse() {
        if (this.loaded) {
            for(let i = 0; i < this.numberOfChannels; i++){
                this.getChannelData(i).reverse();
            }
        }
        return this;
    }
    /**
     * If the buffer is loaded or not
     */ get loaded() {
        return this.length > 0;
    }
    /**
     * The duration of the buffer in seconds.
     */ get duration() {
        if (this._buffer) {
            return this._buffer.duration;
        } else {
            return 0;
        }
    }
    /**
     * The length of the buffer in samples
     */ get length() {
        if (this._buffer) {
            return this._buffer.length;
        } else {
            return 0;
        }
    }
    /**
     * The number of discrete audio channels. Returns 0 if no buffer is loaded.
     */ get numberOfChannels() {
        if (this._buffer) {
            return this._buffer.numberOfChannels;
        } else {
            return 0;
        }
    }
    /**
     * Reverse the buffer.
     */ get reverse() {
        return this._reversed;
    }
    set reverse(rev) {
        if (this._reversed !== rev) {
            this._reversed = rev;
            this._reverse();
        }
    }
    /**
     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
     * pass in a multidimensional array.
     * @param array The array to fill the audio buffer
     * @return A ToneAudioBuffer created from the array
     */ static fromArray(array) {
        return new ToneAudioBuffer().fromArray(array);
    }
    /**
     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
     * @param  url The url to load.
     * @return A promise which resolves to a ToneAudioBuffer
     */ static fromUrl(url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            const buffer = new ToneAudioBuffer();
            return yield buffer.load(url);
        });
    }
    /**
     * Loads a url using fetch and returns the AudioBuffer.
     */ static load(url) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            // make sure there is a slash between the baseUrl and the url
            const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
            const response = yield fetch(baseUrl + url);
            if (!response.ok) {
                throw new Error(`could not load url: ${url}`);
            }
            const arrayBuffer = yield response.arrayBuffer();
            const audioBuffer = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])().decodeAudioData(arrayBuffer);
            return audioBuffer;
        });
    }
    /**
     * Checks a url's extension to see if the current browser can play that file type.
     * @param url The url/extension to test
     * @return If the file extension can be played
     * @static
     * @example
     * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
     * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
     */ static supportsType(url) {
        const extensions = url.split(".");
        const extension = extensions[extensions.length - 1];
        const response = document.createElement("audio").canPlayType("audio/" + extension);
        return response !== "";
    }
    /**
     * Returns a Promise which resolves when all of the buffers have loaded
     */ static loaded() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            // this makes sure that the function is always async
            yield Promise.resolve();
            while(ToneAudioBuffer.downloads.length){
                yield ToneAudioBuffer.downloads[0];
            }
        });
    }
}
//-------------------------------------
// STATIC METHODS
//-------------------------------------
/**
 * A path which is prefixed before every url.
 */ ToneAudioBuffer.baseUrl = "";
/**
 * All of the downloads
 */ ToneAudioBuffer.downloads = []; //# sourceMappingURL=ToneAudioBuffer.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/OfflineContext.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OfflineContext",
    ()=>OfflineContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/AudioContext.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)");
;
;
;
;
;
class OfflineContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"] {
    constructor(){
        super({
            clockSource: "offline",
            context: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOfflineAudioContext"])(arguments[0]) ? arguments[0] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createOfflineAudioContext"])(arguments[0], arguments[1] * arguments[2], arguments[2]),
            lookAhead: 0,
            updateInterval: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOfflineAudioContext"])(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
        });
        this.name = "OfflineContext";
        /**
         * An artificial clock source
         */ this._currentTime = 0;
        this.isOffline = true;
        this._duration = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOfflineAudioContext"])(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
    }
    /**
     * Override the now method to point to the internal clock time
     */ now() {
        return this._currentTime;
    }
    /**
     * Same as this.now()
     */ get currentTime() {
        return this._currentTime;
    }
    /**
     * Render just the clock portion of the audio context.
     */ _renderClock(asynchronous) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, void 0, void 0, function*() {
            let index = 0;
            while(this._duration - this._currentTime >= 0){
                // invoke all the callbacks on that time
                this.emit("tick");
                // increment the clock in block-sized chunks
                this._currentTime += 128 / this.sampleRate;
                // yield once a second of audio
                index++;
                const yieldEvery = Math.floor(this.sampleRate / 128);
                if (asynchronous && index % yieldEvery === 0) {
                    yield new Promise((done)=>setTimeout(done, 1));
                }
            }
        });
    }
    /**
     * Render the output of the OfflineContext
     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
     */ render() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, arguments, void 0, function*(asynchronous = true) {
            yield this.workletsAreReady();
            yield this._renderClock(asynchronous);
            const buffer = yield this._context.startRendering();
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffer"](buffer);
        });
    }
    /**
     * Close the context
     */ close() {
        return Promise.resolve();
    }
} //# sourceMappingURL=OfflineContext.js.map
}),
"[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getContext",
    ()=>getContext,
    "setContext",
    ()=>setContext,
    "start",
    ()=>start
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/AudioContext.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$DummyContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/DummyContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/OfflineContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * This dummy context is used to avoid throwing immediate errors when importing in Node.js
 */ const dummyContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$DummyContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DummyContext"]();
/**
 * The global audio context which is getable and assignable through
 * getContext and setContext
 */ let globalContext = dummyContext;
function getContext() {
    if (globalContext === dummyContext && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hasAudioContext"]) {
        setContext(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"]());
    }
    return globalContext;
}
function setContext(context, disposeOld = false) {
    if (disposeOld) {
        globalContext.dispose();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioContext"])(context)) {
        globalContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"](context);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOfflineAudioContext"])(context)) {
        globalContext = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OfflineContext"](context);
    } else {
        globalContext = context;
    }
}
function start() {
    return globalContext.resume();
}
/**
 * Log Tone.js + version in the console.
 */ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["theWindow"] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$AudioContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["theWindow"].TONE_SILENCE_LOGGING) {
    let prefix = "v";
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] === "dev") {
        prefix = "";
    }
    const printString = ` * Tone.js ${prefix}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]} * `;
    // eslint-disable-next-line no-console
    console.log(`%c${printString}`, "background: #000; color: #fff");
} //# sourceMappingURL=Global.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Equal power gain scale. Good for cross-fading.
 * @param  percent (0-1)
 */ __turbopack_context__.s([
    "dbToGain",
    ()=>dbToGain,
    "equalPowerScale",
    ()=>equalPowerScale,
    "ftom",
    ()=>ftom,
    "ftomf",
    ()=>ftomf,
    "gainToDb",
    ()=>gainToDb,
    "getA4",
    ()=>getA4,
    "intervalToFrequencyRatio",
    ()=>intervalToFrequencyRatio,
    "mtof",
    ()=>mtof,
    "setA4",
    ()=>setA4
]);
function equalPowerScale(percent) {
    const piFactor = 0.5 * Math.PI;
    return Math.sin(percent * piFactor);
}
function dbToGain(db) {
    return Math.pow(10, db / 20);
}
function gainToDb(gain) {
    return 20 * (Math.log(gain) / Math.LN10);
}
function intervalToFrequencyRatio(interval) {
    return Math.pow(2, interval / 12);
}
/**
 * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
 * to generate all the other pitch values from notes. A4's values in Hertz.
 */ let A4 = 440;
function getA4() {
    return A4;
}
function setA4(freq) {
    A4 = freq;
}
function ftom(frequency) {
    return Math.round(ftomf(frequency));
}
function ftomf(frequency) {
    return 69 + 12 * Math.log2(frequency / A4);
}
function mtof(midi) {
    return A4 * Math.pow(2, (midi - 69) / 12);
} //# sourceMappingURL=Conversions.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/TimeBase.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TimeBaseClass",
    ()=>TimeBaseClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
class TimeBaseClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    /**
     * @param context The context associated with the time value. Used to compute
     * Transport and context-relative timing.
     * @param  value  The time value as a number, string or object
     * @param  units  Unit values
     */ constructor(context, value, units){
        super();
        /**
         * The default units
         */ this.defaultUnits = "s";
        this._val = value;
        this._units = units;
        this.context = context;
        this._expressions = this._getExpressions();
    }
    /**
     * All of the time encoding expressions
     */ _getExpressions() {
        return {
            hz: {
                method: (value)=>{
                    return this._frequencyToUnits(parseFloat(value));
                },
                regexp: /^(\d+(?:\.\d+)?)hz$/i
            },
            i: {
                method: (value)=>{
                    return this._ticksToUnits(parseInt(value, 10));
                },
                regexp: /^(\d+)i$/i
            },
            m: {
                method: (value)=>{
                    return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
                },
                regexp: /^(\d+)m$/i
            },
            n: {
                method: (value, dot)=>{
                    const numericValue = parseInt(value, 10);
                    const scalar = dot === "." ? 1.5 : 1;
                    if (numericValue === 1) {
                        return this._beatsToUnits(this._getTimeSignature()) * scalar;
                    } else {
                        return this._beatsToUnits(4 / numericValue) * scalar;
                    }
                },
                regexp: /^(\d+)n(\.?)$/i
            },
            number: {
                method: (value)=>{
                    return this._expressions[this.defaultUnits].method.call(this, value);
                },
                regexp: /^(\d+(?:\.\d+)?)$/
            },
            s: {
                method: (value)=>{
                    return this._secondsToUnits(parseFloat(value));
                },
                regexp: /^(\d+(?:\.\d+)?)s$/
            },
            samples: {
                method: (value)=>{
                    return parseInt(value, 10) / this.context.sampleRate;
                },
                regexp: /^(\d+)samples$/
            },
            t: {
                method: (value)=>{
                    const numericValue = parseInt(value, 10);
                    return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
                },
                regexp: /^(\d+)t$/i
            },
            tr: {
                method: (m, q, s)=>{
                    let total = 0;
                    if (m && m !== "0") {
                        total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
                    }
                    if (q && q !== "0") {
                        total += this._beatsToUnits(parseFloat(q));
                    }
                    if (s && s !== "0") {
                        total += this._beatsToUnits(parseFloat(s) / 4);
                    }
                    return total;
                },
                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
            }
        };
    }
    //-------------------------------------
    // 	VALUE OF
    //-------------------------------------
    /**
     * Evaluate the time value. Returns the time in seconds.
     */ valueOf() {
        if (this._val instanceof TimeBaseClass) {
            this.fromType(this._val);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(this._val)) {
            return this._noArg();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(this._val) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(this._units)) {
            for(const units in this._expressions){
                if (this._expressions[units].regexp.test(this._val.trim())) {
                    this._units = units;
                    break;
                }
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(this._val)) {
            let total = 0;
            for(const typeName in this._val){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this._val[typeName])) {
                    const quantity = this._val[typeName];
                    const time = // @ts-ignore
                    new this.constructor(this.context, typeName).valueOf() * quantity;
                    total += time;
                }
            }
            return total;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this._units)) {
            const expr = this._expressions[this._units];
            const matching = this._val.toString().trim().match(expr.regexp);
            if (matching) {
                return expr.method.apply(this, matching.slice(1));
            } else {
                return expr.method.call(this, this._val);
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(this._val)) {
            return parseFloat(this._val);
        } else {
            return this._val;
        }
    }
    //-------------------------------------
    // 	UNIT CONVERSIONS
    //-------------------------------------
    /**
     * Returns the value of a frequency in the current units
     */ _frequencyToUnits(freq) {
        return 1 / freq;
    }
    /**
     * Return the value of the beats in the current units
     */ _beatsToUnits(beats) {
        return 60 / this._getBpm() * beats;
    }
    /**
     * Returns the value of a second in the current units
     */ _secondsToUnits(seconds) {
        return seconds;
    }
    /**
     * Returns the value of a tick in the current time units
     */ _ticksToUnits(ticks) {
        return ticks * this._beatsToUnits(1) / this._getPPQ();
    }
    /**
     * With no arguments, return 'now'
     */ _noArg() {
        return this._now();
    }
    //-------------------------------------
    // 	TEMPO CONVERSIONS
    //-------------------------------------
    /**
     * Return the bpm
     */ _getBpm() {
        return this.context.transport.bpm.value;
    }
    /**
     * Return the timeSignature
     */ _getTimeSignature() {
        return this.context.transport.timeSignature;
    }
    /**
     * Return the PPQ or 192 if Transport is not available
     */ _getPPQ() {
        return this.context.transport.PPQ;
    }
    //-------------------------------------
    // 	CONVERSION INTERFACE
    //-------------------------------------
    /**
     * Coerce a time type into this units type.
     * @param type Any time type units
     */ fromType(type) {
        this._units = undefined;
        switch(this.defaultUnits){
            case "s":
                this._val = type.toSeconds();
                break;
            case "i":
                this._val = type.toTicks();
                break;
            case "hz":
                this._val = type.toFrequency();
                break;
            case "midi":
                this._val = type.toMidi();
                break;
        }
        return this;
    }
    /**
     * Return the value in hertz
     */ toFrequency() {
        return 1 / this.toSeconds();
    }
    /**
     * Return the time in samples
     */ toSamples() {
        return this.toSeconds() * this.context.sampleRate;
    }
    /**
     * Return the time in milliseconds.
     */ toMilliseconds() {
        return this.toSeconds() * 1000;
    }
} //# sourceMappingURL=TimeBase.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Time",
    ()=>Time,
    "TimeClass",
    ()=>TimeClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TimeBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TimeBase.js [app-client] (ecmascript)");
;
;
;
class TimeClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TimeBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeBaseClass"] {
    constructor(){
        super(...arguments);
        this.name = "TimeClass";
    }
    _getExpressions() {
        return Object.assign(super._getExpressions(), {
            now: {
                method: (capture)=>{
                    return this._now() + new this.constructor(this.context, capture).valueOf();
                },
                regexp: /^\+(.+)/
            },
            quantize: {
                method: (capture)=>{
                    const quantTo = new TimeClass(this.context, capture).valueOf();
                    return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
                },
                regexp: /^@(.+)/
            }
        });
    }
    /**
     * Quantize the time by the given subdivision. Optionally add a
     * percentage which will move the time value towards the ideal
     * quantized value by that percentage.
     * @param  subdiv    The subdivision to quantize to
     * @param  percent  Move the time value towards the quantized value by a percentage.
     * @example
     * Tone.Time(21).quantize(2); // returns 22
     * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
     */ quantize(subdiv, percent = 1) {
        const subdivision = new this.constructor(this.context, subdiv).valueOf();
        const value = this.valueOf();
        const multiple = Math.round(value / subdivision);
        const ideal = multiple * subdivision;
        const diff = ideal - value;
        return value + diff * percent;
    }
    //-------------------------------------
    // CONVERSIONS
    //-------------------------------------
    /**
     * Convert a Time to Notation. The notation values are will be the
     * closest representation between 1m to 128th note.
     * @return {Notation}
     * @example
     * // if the Transport is at 120bpm:
     * Tone.Time(2).toNotation(); // returns "1m"
     */ toNotation() {
        const time = this.toSeconds();
        const testNotations = [
            "1m"
        ];
        for(let power = 1; power < 9; power++){
            const subdiv = Math.pow(2, power);
            testNotations.push(subdiv + "n.");
            testNotations.push(subdiv + "n");
            testNotations.push(subdiv + "t");
        }
        testNotations.push("0");
        // find the closets notation representation
        let closest = testNotations[0];
        let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
        testNotations.forEach((notation)=>{
            const notationSeconds = new TimeClass(this.context, notation).toSeconds();
            if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {
                closest = notation;
                closestSeconds = notationSeconds;
            }
        });
        return closest;
    }
    /**
     * Return the time encoded as Bars:Beats:Sixteenths.
     */ toBarsBeatsSixteenths() {
        const quarterTime = this._beatsToUnits(1);
        let quarters = this.valueOf() / quarterTime;
        quarters = parseFloat(quarters.toFixed(4));
        const measures = Math.floor(quarters / this._getTimeSignature());
        let sixteenths = quarters % 1 * 4;
        quarters = Math.floor(quarters) % this._getTimeSignature();
        const sixteenthString = sixteenths.toString();
        if (sixteenthString.length > 3) {
            // the additional parseFloat removes insignificant trailing zeroes
            sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
        }
        const progress = [
            measures,
            quarters,
            sixteenths
        ];
        return progress.join(":");
    }
    /**
     * Return the time in ticks.
     */ toTicks() {
        const quarterTime = this._beatsToUnits(1);
        const quarters = this.valueOf() / quarterTime;
        return quarters * this._getPPQ();
    }
    /**
     * Return the time in seconds.
     */ toSeconds() {
        return this.valueOf();
    }
    /**
     * Return the value as a midi note.
     */ toMidi() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(this.toFrequency());
    }
    _now() {
        return this.context.now();
    }
}
function Time(value, units) {
    return new TimeClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])(), value, units);
} //# sourceMappingURL=Time.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Frequency.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable key-spacing */ __turbopack_context__.s([
    "Frequency",
    ()=>Frequency,
    "FrequencyClass",
    ()=>FrequencyClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
;
;
;
;
class FrequencyClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"] {
    constructor(){
        super(...arguments);
        this.name = "Frequency";
        this.defaultUnits = "hz";
    }
    /**
     * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
     * to generate all the other pitch values from notes. A4's values in Hertz.
     */ static get A4() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getA4"])();
    }
    static set A4(freq) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setA4"])(freq);
    }
    //-------------------------------------
    // 	AUGMENT BASE EXPRESSIONS
    //-------------------------------------
    _getExpressions() {
        return Object.assign({}, super._getExpressions(), {
            midi: {
                regexp: /^(\d+(?:\.\d+)?midi)/,
                method (value) {
                    if (this.defaultUnits === "midi") {
                        return value;
                    } else {
                        return FrequencyClass.mtof(value);
                    }
                }
            },
            note: {
                regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
                method (pitch, octave) {
                    const index = noteToScaleIndex[pitch.toLowerCase()];
                    const noteNumber = index + (parseInt(octave, 10) + 1) * 12;
                    if (this.defaultUnits === "midi") {
                        return noteNumber;
                    } else {
                        return FrequencyClass.mtof(noteNumber);
                    }
                }
            },
            tr: {
                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                method (m, q, s) {
                    let total = 1;
                    if (m && m !== "0") {
                        total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
                    }
                    if (q && q !== "0") {
                        total *= this._beatsToUnits(parseFloat(q));
                    }
                    if (s && s !== "0") {
                        total *= this._beatsToUnits(parseFloat(s) / 4);
                    }
                    return total;
                }
            }
        });
    }
    //-------------------------------------
    // 	EXPRESSIONS
    //-------------------------------------
    /**
     * Transposes the frequency by the given number of semitones.
     * @return  A new transposed frequency
     * @example
     * Tone.Frequency("A4").transpose(3); // "C5"
     */ transpose(interval) {
        return new FrequencyClass(this.context, this.valueOf() * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intervalToFrequencyRatio"])(interval));
    }
    /**
     * Takes an array of semitone intervals and returns
     * an array of frequencies transposed by those intervals.
     * @return  Returns an array of Frequencies
     * @example
     * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
     */ harmonize(intervals) {
        return intervals.map((interval)=>{
            return this.transpose(interval);
        });
    }
    //-------------------------------------
    // 	UNIT CONVERSIONS
    //-------------------------------------
    /**
     * Return the value of the frequency as a MIDI note
     * @example
     * Tone.Frequency("C4").toMidi(); // 60
     */ toMidi() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(this.valueOf());
    }
    /**
     * Return the value of the frequency in Scientific Pitch Notation
     * @example
     * Tone.Frequency(69, "midi").toNote(); // "A4"
     */ toNote() {
        const freq = this.toFrequency();
        const log = Math.log2(freq / FrequencyClass.A4);
        let noteNumber = Math.round(12 * log) + 57;
        const octave = Math.floor(noteNumber / 12);
        if (octave < 0) {
            noteNumber += -12 * octave;
        }
        const noteName = scaleIndexToNote[noteNumber % 12];
        return noteName + octave.toString();
    }
    /**
     * Return the duration of one cycle in seconds.
     */ toSeconds() {
        return 1 / super.toSeconds();
    }
    /**
     * Return the duration of one cycle in ticks
     */ toTicks() {
        const quarterTime = this._beatsToUnits(1);
        const quarters = this.valueOf() / quarterTime;
        return Math.floor(quarters * this._getPPQ());
    }
    //-------------------------------------
    // 	UNIT CONVERSIONS HELPERS
    //-------------------------------------
    /**
     * With no arguments, return 0
     */ _noArg() {
        return 0;
    }
    /**
     * Returns the value of a frequency in the current units
     */ _frequencyToUnits(freq) {
        return freq;
    }
    /**
     * Returns the value of a tick in the current time units
     */ _ticksToUnits(ticks) {
        return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
    }
    /**
     * Return the value of the beats in the current units
     */ _beatsToUnits(beats) {
        return 1 / super._beatsToUnits(beats);
    }
    /**
     * Returns the value of a second in the current units
     */ _secondsToUnits(seconds) {
        return 1 / seconds;
    }
    /**
     * Convert a MIDI note to frequency value.
     * @param  midi The midi number to convert.
     * @return The corresponding frequency value
     */ static mtof(midi) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mtof"])(midi);
    }
    /**
     * Convert a frequency value to a MIDI note.
     * @param frequency The value to frequency value to convert.
     */ static ftom(frequency) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(frequency);
    }
}
//-------------------------------------
// 	FREQUENCY CONVERSIONS
//-------------------------------------
/**
 * Note to scale index.
 * @hidden
 */ const noteToScaleIndex = {
    cbbb: -3,
    cbb: -2,
    cb: -1,
    c: 0,
    "c#": 1,
    cx: 2,
    "c##": 2,
    "c###": 3,
    "cx#": 3,
    "c#x": 3,
    dbbb: -1,
    dbb: 0,
    db: 1,
    d: 2,
    "d#": 3,
    dx: 4,
    "d##": 4,
    "d###": 5,
    "dx#": 5,
    "d#x": 5,
    ebbb: 1,
    ebb: 2,
    eb: 3,
    e: 4,
    "e#": 5,
    ex: 6,
    "e##": 6,
    "e###": 7,
    "ex#": 7,
    "e#x": 7,
    fbbb: 2,
    fbb: 3,
    fb: 4,
    f: 5,
    "f#": 6,
    fx: 7,
    "f##": 7,
    "f###": 8,
    "fx#": 8,
    "f#x": 8,
    gbbb: 4,
    gbb: 5,
    gb: 6,
    g: 7,
    "g#": 8,
    gx: 9,
    "g##": 9,
    "g###": 10,
    "gx#": 10,
    "g#x": 10,
    abbb: 6,
    abb: 7,
    ab: 8,
    a: 9,
    "a#": 10,
    ax: 11,
    "a##": 11,
    "a###": 12,
    "ax#": 12,
    "a#x": 12,
    bbbb: 8,
    bbb: 9,
    bb: 10,
    b: 11,
    "b#": 12,
    bx: 13,
    "b##": 13,
    "b###": 14,
    "bx#": 14,
    "b#x": 14
};
/**
 * scale index to note (sharps)
 * @hidden
 */ const scaleIndexToNote = [
    "C",
    "C#",
    "D",
    "D#",
    "E",
    "F",
    "F#",
    "G",
    "G#",
    "A",
    "A#",
    "B"
];
function Frequency(value, units) {
    return new FrequencyClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])(), value, units);
} //# sourceMappingURL=Frequency.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransportTime",
    ()=>TransportTime,
    "TransportTimeClass",
    ()=>TransportTimeClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
;
;
class TransportTimeClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"] {
    constructor(){
        super(...arguments);
        this.name = "TransportTime";
    }
    /**
     * Return the current time in whichever context is relevant
     */ _now() {
        return this.context.transport.seconds;
    }
}
function TransportTime(value, units) {
    return new TransportTimeClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])(), value, units);
} //# sourceMappingURL=TransportTime.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToneWithContext",
    ()=>ToneWithContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Frequency.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
class ToneWithContext extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super();
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(ToneWithContext.getDefaults(), arguments, [
            "context"
        ]);
        if (this.defaultContext) {
            this.context = this.defaultContext;
        } else {
            this.context = options.context;
        }
    }
    static getDefaults() {
        return {
            context: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])()
        };
    }
    /**
     * Return the current time of the Context clock plus the lookAhead.
     * @example
     * setInterval(() => {
     * 	console.log(Tone.now());
     * }, 100);
     */ now() {
        return this.context.currentTime + this.context.lookAhead;
    }
    /**
     * Return the current time of the Context clock without any lookAhead.
     * @example
     * setInterval(() => {
     * 	console.log(Tone.immediate());
     * }, 100);
     */ immediate() {
        return this.context.currentTime;
    }
    /**
     * The duration in seconds of one sample.
     */ get sampleTime() {
        return 1 / this.context.sampleRate;
    }
    /**
     * The number of seconds of 1 processing block (128 samples)
     * @example
     * console.log(Tone.Destination.blockTime);
     */ get blockTime() {
        return 128 / this.context.sampleRate;
    }
    /**
     * Convert the incoming time to seconds.
     * This is calculated against the current {@link TransportClass} bpm
     * @example
     * const gain = new Tone.Gain();
     * setInterval(() => console.log(gain.toSeconds("4n")), 100);
     * // ramp the tempo to 60 bpm over 30 seconds
     * Tone.getTransport().bpm.rampTo(60, 30);
     */ toSeconds(time) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertUsedScheduleTime"])(time);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"](this.context, time).toSeconds();
    }
    /**
     * Convert the input to a frequency number
     * @example
     * const gain = new Tone.Gain();
     * console.log(gain.toFrequency("4n"));
     */ toFrequency(freq) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrequencyClass"](this.context, freq).toFrequency();
    }
    /**
     * Convert the input time into ticks
     * @example
     * const gain = new Tone.Gain();
     * console.log(gain.toTicks("4n"));
     */ toTicks(time) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"](this.context, time).toTicks();
    }
    //-------------------------------------
    // 	GET/SET
    //-------------------------------------
    /**
     * Get a subset of the properties which are in the partial props
     */ _getPartialProperties(props) {
        const options = this.get();
        // remove attributes from the prop that are not in the partial
        Object.keys(options).forEach((name)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(props[name])) {
                delete options[name];
            }
        });
        return options;
    }
    /**
     * Get the object's attributes.
     * @example
     * const osc = new Tone.Oscillator();
     * console.log(osc.get());
     */ get() {
        const defaults = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultsFromInstance"])(this);
        Object.keys(defaults).forEach((attribute)=>{
            if (Reflect.has(this, attribute)) {
                const member = this[attribute];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(member) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(member.value) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(member.setValueAtTime)) {
                    defaults[attribute] = member.value;
                } else if (member instanceof ToneWithContext) {
                    defaults[attribute] = member._getPartialProperties(defaults[attribute]);
                // otherwise make sure it's a serializable type
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(member) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(member) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(member) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBoolean"])(member)) {
                    defaults[attribute] = member;
                } else {
                    // remove all undefined and unserializable attributes
                    delete defaults[attribute];
                }
            }
        });
        return defaults;
    }
    /**
     * Set multiple properties at once with an object.
     * @example
     * const filter = new Tone.Filter().toDestination();
     * // set values using an object
     * filter.set({
     * 	frequency: "C6",
     * 	type: "highpass"
     * });
     * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
     * player.autostart = true;
     */ set(props) {
        Object.keys(props).forEach((attribute)=>{
            if (Reflect.has(this, attribute) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this[attribute])) {
                if (this[attribute] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this[attribute].value) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this[attribute].setValueAtTime)) {
                    // small optimization
                    if (this[attribute].value !== props[attribute]) {
                        this[attribute].value = props[attribute];
                    }
                } else if (this[attribute] instanceof ToneWithContext) {
                    this[attribute].set(props[attribute]);
                } else {
                    this[attribute] = props[attribute];
                }
            }
        });
        return this;
    }
} //# sourceMappingURL=ToneWithContext.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/StateTimeline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StateTimeline",
    ()=>StateTimeline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
class StateTimeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"] {
    constructor(initial = "stopped"){
        super();
        this.name = "StateTimeline";
        this._initial = initial;
        this.setStateAtTime(this._initial, 0);
    }
    /**
     * Returns the scheduled state scheduled before or at
     * the given time.
     * @param  time  The time to query.
     * @return  The name of the state input in setStateAtTime.
     */ getValueAtTime(time) {
        const event = this.get(time);
        if (event !== null) {
            return event.state;
        } else {
            return this._initial;
        }
    }
    /**
     * Add a state to the timeline.
     * @param  state The name of the state to set.
     * @param  time  The time to query.
     * @param options Any additional options that are needed in the timeline.
     */ setStateAtTime(state, time, options) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertRange"])(time, 0);
        this.add(Object.assign({}, options, {
            state,
            time
        }));
        return this;
    }
    /**
     * Return the event before the time with the given state
     * @param  state The state to look for
     * @param  time  When to check before
     * @return  The event with the given state before the time
     */ getLastState(state, time) {
        // time = this.toSeconds(time);
        const index = this._search(time);
        for(let i = index; i >= 0; i--){
            const event = this._timeline[i];
            if (event.state === state) {
                return event;
            }
        }
    }
    /**
     * Return the event after the time with the given state
     * @param  state The state to look for
     * @param  time  When to check from
     * @return  The event with the given state after the time
     */ getNextState(state, time) {
        // time = this.toSeconds(time);
        const index = this._search(time);
        if (index !== -1) {
            for(let i = index; i < this._timeline.length; i++){
                const event = this._timeline[i];
                if (event.state === state) {
                    return event;
                }
            }
        }
    }
} //# sourceMappingURL=StateTimeline.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Param",
    ()=>Param
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
class Param extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Param.getDefaults(), arguments, [
            "param",
            "units",
            "convert"
        ]);
        super(options);
        this.name = "Param";
        this.overridden = false;
        /**
         * The minimum output value
         */ this._minOutput = 1e-7;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(options.param) && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(options.param) || options.param instanceof Param), "param must be an AudioParam");
        while(!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(options.param)){
            options.param = options.param._param;
        }
        this._swappable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(options.swappable) ? options.swappable : false;
        if (this._swappable) {
            this.input = this.context.createGain();
            // initialize
            this._param = options.param;
            this.input.connect(this._param);
        } else {
            this._param = this.input = options.param;
        }
        this._events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"](1000);
        this._initialValue = this._param.defaultValue;
        this.units = options.units;
        this.convert = options.convert;
        this._minValue = options.minValue;
        this._maxValue = options.maxValue;
        // if the value is defined, set it immediately
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(options.value) && options.value !== this._toType(this._initialValue)) {
            this.setValueAtTime(options.value, 0);
        }
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"].getDefaults(), {
            convert: true,
            units: "number"
        });
    }
    get value() {
        const now = this.now();
        return this.getValueAtTime(now);
    }
    set value(value) {
        this.cancelScheduledValues(this.now());
        this.setValueAtTime(value, this.now());
    }
    get minValue() {
        // if it's not the default minValue, return it
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this._minValue)) {
            return this._minValue;
        } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
            return 0;
        } else if (this.units === "audioRange") {
            return -1;
        } else if (this.units === "decibels") {
            return -Infinity;
        } else {
            return this._param.minValue;
        }
    }
    get maxValue() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this._maxValue)) {
            return this._maxValue;
        } else if (this.units === "normalRange" || this.units === "audioRange") {
            return 1;
        } else {
            return this._param.maxValue;
        }
    }
    /**
     * Type guard based on the unit name
     */ _is(arg, type) {
        return this.units === type;
    }
    /**
     * Make sure the value is always in the defined range
     */ _assertRange(value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.maxValue) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.minValue)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertRange"])(value, this._fromType(this.minValue), this._fromType(this.maxValue));
        }
        return value;
    }
    /**
     * Convert the given value from the type specified by Param.units
     * into the destination value (such as Gain or Frequency).
     */ _fromType(val) {
        if (this.convert && !this.overridden) {
            if (this._is(val, "time")) {
                return this.toSeconds(val);
            } else if (this._is(val, "decibels")) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dbToGain"])(val);
            } else if (this._is(val, "frequency")) {
                return this.toFrequency(val);
            } else {
                return val;
            }
        } else if (this.overridden) {
            // if it's overridden, should only schedule 0s
            return 0;
        } else {
            return val;
        }
    }
    /**
     * Convert the parameters value into the units specified by Param.units.
     */ _toType(val) {
        if (this.convert && this.units === "decibels") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gainToDb"])(val);
        } else {
            return val;
        }
    }
    //-------------------------------------
    // ABSTRACT PARAM INTERFACE
    // all docs are generated from ParamInterface.ts
    //-------------------------------------
    setValueAtTime(value, time) {
        const computedTime = this.toSeconds(time);
        const numericValue = this._fromType(value);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);
        this._assertRange(numericValue);
        this.log(this.units, "setValueAtTime", value, computedTime);
        this._events.add({
            time: computedTime,
            type: "setValueAtTime",
            value: numericValue
        });
        this._param.setValueAtTime(numericValue, computedTime);
        return this;
    }
    getValueAtTime(time) {
        const computedTime = Math.max(this.toSeconds(time), 0);
        const after = this._events.getAfter(computedTime);
        const before = this._events.get(computedTime);
        let value = this._initialValue;
        // if it was set by
        if (before === null) {
            value = this._initialValue;
        } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
            const previous = this._events.getBefore(before.time);
            let previousVal;
            if (previous === null) {
                previousVal = this._initialValue;
            } else {
                previousVal = previous.value;
            }
            if (before.type === "setTargetAtTime") {
                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
            }
        } else if (after === null) {
            value = before.value;
        } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
            let beforeValue = before.value;
            if (before.type === "setTargetAtTime") {
                const previous = this._events.getBefore(before.time);
                if (previous === null) {
                    beforeValue = this._initialValue;
                } else {
                    beforeValue = previous.value;
                }
            }
            if (after.type === "linearRampToValueAtTime") {
                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
            } else {
                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
            }
        } else {
            value = before.value;
        }
        return this._toType(value);
    }
    setRampPoint(time) {
        time = this.toSeconds(time);
        let currentVal = this.getValueAtTime(time);
        this.cancelAndHoldAtTime(time);
        if (this._fromType(currentVal) === 0) {
            currentVal = this._toType(this._minOutput);
        }
        this.setValueAtTime(currentVal, time);
        return this;
    }
    linearRampToValueAtTime(value, endTime) {
        const numericValue = this._fromType(value);
        const computedTime = this.toSeconds(endTime);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
        this._assertRange(numericValue);
        this._events.add({
            time: computedTime,
            type: "linearRampToValueAtTime",
            value: numericValue
        });
        this.log(this.units, "linearRampToValueAtTime", value, computedTime);
        this._param.linearRampToValueAtTime(numericValue, computedTime);
        return this;
    }
    exponentialRampToValueAtTime(value, endTime) {
        let numericValue = this._fromType(value);
        // the value can't be 0
        numericValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(numericValue, 0) ? this._minOutput : numericValue;
        this._assertRange(numericValue);
        const computedTime = this.toSeconds(endTime);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
        // store the event
        this._events.add({
            time: computedTime,
            type: "exponentialRampToValueAtTime",
            value: numericValue
        });
        this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
        this._param.exponentialRampToValueAtTime(numericValue, computedTime);
        return this;
    }
    exponentialRampTo(value, rampTime, startTime) {
        startTime = this.toSeconds(startTime);
        this.setRampPoint(startTime);
        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
        return this;
    }
    linearRampTo(value, rampTime, startTime) {
        startTime = this.toSeconds(startTime);
        this.setRampPoint(startTime);
        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
        return this;
    }
    targetRampTo(value, rampTime, startTime) {
        startTime = this.toSeconds(startTime);
        this.setRampPoint(startTime);
        this.exponentialApproachValueAtTime(value, startTime, rampTime);
        return this;
    }
    exponentialApproachValueAtTime(value, time, rampTime) {
        time = this.toSeconds(time);
        rampTime = this.toSeconds(rampTime);
        const timeConstant = Math.log(rampTime + 1) / Math.log(200);
        this.setTargetAtTime(value, time, timeConstant);
        // at 90% start a linear ramp to the final value
        this.cancelAndHoldAtTime(time + rampTime * 0.9);
        this.linearRampToValueAtTime(value, time + rampTime);
        return this;
    }
    setTargetAtTime(value, startTime, timeConstant) {
        const numericValue = this._fromType(value);
        // The value will never be able to approach without timeConstant > 0.
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
        const computedTime = this.toSeconds(startTime);
        this._assertRange(numericValue);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
        this._events.add({
            constant: timeConstant,
            time: computedTime,
            type: "setTargetAtTime",
            value: numericValue
        });
        this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
        return this;
    }
    setValueCurveAtTime(values, startTime, duration, scaling = 1) {
        duration = this.toSeconds(duration);
        startTime = this.toSeconds(startTime);
        const startingValue = this._fromType(values[0]) * scaling;
        this.setValueAtTime(this._toType(startingValue), startTime);
        const segTime = duration / (values.length - 1);
        for(let i = 1; i < values.length; i++){
            const numericValue = this._fromType(values[i]) * scaling;
            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);
        }
        return this;
    }
    cancelScheduledValues(time) {
        const computedTime = this.toSeconds(time);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);
        this._events.cancel(computedTime);
        this._param.cancelScheduledValues(computedTime);
        this.log(this.units, "cancelScheduledValues", computedTime);
        return this;
    }
    cancelAndHoldAtTime(time) {
        const computedTime = this.toSeconds(time);
        const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
        // remove the schedule events
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);
        this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
        // if there is an event at the given computedTime
        // and that even is not a "set"
        const before = this._events.get(computedTime);
        const after = this._events.getAfter(computedTime);
        if (before && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(before.time, computedTime)) {
            // remove everything after
            if (after) {
                this._param.cancelScheduledValues(after.time);
                this._events.cancel(after.time);
            } else {
                this._param.cancelAndHoldAtTime(computedTime);
                this._events.cancel(computedTime + this.sampleTime);
            }
        } else if (after) {
            this._param.cancelScheduledValues(after.time);
            // cancel the next event(s)
            this._events.cancel(after.time);
            if (after.type === "linearRampToValueAtTime") {
                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
            } else if (after.type === "exponentialRampToValueAtTime") {
                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
            }
        }
        // set the value at the given time
        this._events.add({
            time: computedTime,
            type: "setValueAtTime",
            value: valueAtTime
        });
        this._param.setValueAtTime(valueAtTime, computedTime);
        return this;
    }
    rampTo(value, rampTime = 0.1, startTime) {
        if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
            this.exponentialRampTo(value, rampTime, startTime);
        } else {
            this.linearRampTo(value, rampTime, startTime);
        }
        return this;
    }
    /**
     * Apply all of the previously scheduled events to the passed in Param or AudioParam.
     * The applied values will start at the context's current time and schedule
     * all of the events which are scheduled on this Param onto the passed in param.
     */ apply(param) {
        const now = this.context.currentTime;
        // set the param's value at the current time and schedule everything else
        param.setValueAtTime(this.getValueAtTime(now), now);
        // if the previous event was a curve, then set the rest of it
        const previousEvent = this._events.get(now);
        if (previousEvent && previousEvent.type === "setTargetAtTime") {
            // approx it until the next event with linear ramps
            const nextEvent = this._events.getAfter(previousEvent.time);
            // or for 2 seconds if there is no event
            const endTime = nextEvent ? nextEvent.time : now + 2;
            const subdivisions = (endTime - now) / 10;
            for(let i = now; i < endTime; i += subdivisions){
                param.linearRampToValueAtTime(this.getValueAtTime(i), i);
            }
        }
        this._events.forEachAfter(this.context.currentTime, (event)=>{
            if (event.type === "cancelScheduledValues") {
                param.cancelScheduledValues(event.time);
            } else if (event.type === "setTargetAtTime") {
                param.setTargetAtTime(event.value, event.time, event.constant);
            } else {
                param[event.type](event.value, event.time);
            }
        });
        return this;
    }
    /**
     * Replace the Param's internal AudioParam. Will apply scheduled curves
     * onto the parameter and replace the connections.
     */ setParam(param) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
        const input = this.input;
        input.disconnect(this._param);
        this.apply(param);
        this._param = param;
        input.connect(this._param);
        return this;
    }
    dispose() {
        super.dispose();
        this._events.dispose();
        return this;
    }
    get defaultValue() {
        return this._toType(this._param.defaultValue);
    }
    //-------------------------------------
    // 	AUTOMATION CURVE CALCULATIONS
    // 	MIT License, copyright (c) 2014 Jordan Santell
    //-------------------------------------
    // Calculates the the value along the curve produced by setTargetAtTime
    _exponentialApproach(t0, v0, v1, timeConstant, t) {
        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
    }
    // Calculates the the value along the curve produced by linearRampToValueAtTime
    _linearInterpolate(t0, v0, t1, v1, t) {
        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
    }
    // Calculates the the value along the curve produced by exponentialRampToValueAtTime
    _exponentialInterpolate(t0, v0, t1, v1, t) {
        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
    }
} //# sourceMappingURL=Param.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToneAudioNode",
    ()=>ToneAudioNode,
    "connect",
    ()=>connect,
    "connectSeries",
    ()=>connectSeries,
    "disconnect",
    ()=>disconnect,
    "fanIn",
    ()=>fanIn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
class ToneAudioNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        super(...arguments);
        /**
         * List all of the node that must be set to match the ChannelProperties
         */ this._internalChannels = [];
    }
    /**
     * The number of inputs feeding into the AudioNode.
     * For source nodes, this will be 0.
     * @example
     * const node = new Tone.Gain();
     * console.log(node.numberOfInputs);
     */ get numberOfInputs() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.input)) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(this.input) || this.input instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]) {
                return 1;
            } else {
                return this.input.numberOfInputs;
            }
        } else {
            return 0;
        }
    }
    /**
     * The number of outputs of the AudioNode.
     * @example
     * const node = new Tone.Gain();
     * console.log(node.numberOfOutputs);
     */ get numberOfOutputs() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.output)) {
            return this.output.numberOfOutputs;
        } else {
            return 0;
        }
    }
    //-------------------------------------
    // AUDIO PROPERTIES
    //-------------------------------------
    /**
     * Used to decide which nodes to get/set properties on
     */ _isAudioNode(node) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(node) && (node instanceof ToneAudioNode || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(node));
    }
    /**
     * Get all of the audio nodes (either internal or input/output) which together
     * make up how the class node responds to channel input/output
     */ _getInternalNodes() {
        const nodeList = this._internalChannels.slice(0);
        if (this._isAudioNode(this.input)) {
            nodeList.push(this.input);
        }
        if (this._isAudioNode(this.output)) {
            if (this.input !== this.output) {
                nodeList.push(this.output);
            }
        }
        return nodeList;
    }
    /**
     * Set the audio options for this node such as channelInterpretation
     * channelCount, etc.
     * @param options
     */ _setChannelProperties(options) {
        const nodeList = this._getInternalNodes();
        nodeList.forEach((node)=>{
            node.channelCount = options.channelCount;
            node.channelCountMode = options.channelCountMode;
            node.channelInterpretation = options.channelInterpretation;
        });
    }
    /**
     * Get the current audio options for this node such as channelInterpretation
     * channelCount, etc.
     */ _getChannelProperties() {
        const nodeList = this._getInternalNodes();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
        // use the first node to get properties
        // they should all be the same
        const node = nodeList[0];
        return {
            channelCount: node.channelCount,
            channelCountMode: node.channelCountMode,
            channelInterpretation: node.channelInterpretation
        };
    }
    /**
     * channelCount is the number of channels used when up-mixing and down-mixing
     * connections to any inputs to the node. The default value is 2 except for
     * specific nodes where its value is specially determined.
     */ get channelCount() {
        return this._getChannelProperties().channelCount;
    }
    set channelCount(channelCount) {
        const props = this._getChannelProperties();
        // merge it with the other properties
        this._setChannelProperties(Object.assign(props, {
            channelCount
        }));
    }
    /**
     * channelCountMode determines how channels will be counted when up-mixing and
     * down-mixing connections to any inputs to the node.
     * The default value is "max". This attribute has no effect for nodes with no inputs.
     * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
     * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
     * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
     */ get channelCountMode() {
        return this._getChannelProperties().channelCountMode;
    }
    set channelCountMode(channelCountMode) {
        const props = this._getChannelProperties();
        // merge it with the other properties
        this._setChannelProperties(Object.assign(props, {
            channelCountMode
        }));
    }
    /**
     * channelInterpretation determines how individual channels will be treated
     * when up-mixing and down-mixing connections to any inputs to the node.
     * The default value is "speakers".
     */ get channelInterpretation() {
        return this._getChannelProperties().channelInterpretation;
    }
    set channelInterpretation(channelInterpretation) {
        const props = this._getChannelProperties();
        // merge it with the other properties
        this._setChannelProperties(Object.assign(props, {
            channelInterpretation
        }));
    }
    //-------------------------------------
    // CONNECTIONS
    //-------------------------------------
    /**
     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
     * @param destination The output to connect to
     * @param outputNum The output to connect from
     * @param inputNum The input to connect to
     */ connect(destination, outputNum = 0, inputNum = 0) {
        connect(this, destination, outputNum, inputNum);
        return this;
    }
    /**
     * Connect the output to the context's destination node.
     * @example
     * const osc = new Tone.Oscillator("C2").start();
     * osc.toDestination();
     */ toDestination() {
        this.connect(this.context.destination);
        return this;
    }
    /**
     * Connect the output to the context's destination node.
     * @see {@link toDestination}
     * @deprecated
     */ toMaster() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("toMaster() has been renamed toDestination()");
        return this.toDestination();
    }
    /**
     * disconnect the output
     */ disconnect(destination, outputNum = 0, inputNum = 0) {
        disconnect(this, destination, outputNum, inputNum);
        return this;
    }
    /**
     * Connect the output of this node to the rest of the nodes in series.
     * @example
     * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
     * player.autostart = true;
     * const filter = new Tone.AutoFilter(4).start();
     * const distortion = new Tone.Distortion(0.5);
     * // connect the player to the filter, distortion and then to the master output
     * player.chain(filter, distortion, Tone.Destination);
     */ chain(...nodes) {
        connectSeries(this, ...nodes);
        return this;
    }
    /**
     * connect the output of this node to the rest of the nodes in parallel.
     * @example
     * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
     * player.autostart = true;
     * const pitchShift = new Tone.PitchShift(4).toDestination();
     * const filter = new Tone.Filter("G5").toDestination();
     * // connect a node to the pitch shift and filter in parallel
     * player.fan(pitchShift, filter);
     */ fan(...nodes) {
        nodes.forEach((node)=>this.connect(node));
        return this;
    }
    /**
     * Dispose and disconnect
     */ dispose() {
        super.dispose();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.input)) {
            if (this.input instanceof ToneAudioNode) {
                this.input.dispose();
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(this.input)) {
                this.input.disconnect();
            }
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.output)) {
            if (this.output instanceof ToneAudioNode) {
                this.output.dispose();
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(this.output)) {
                this.output.disconnect();
            }
        }
        this._internalChannels = [];
        return this;
    }
}
function connectSeries(...nodes) {
    const first = nodes.shift();
    nodes.reduce((prev, current)=>{
        if (prev instanceof ToneAudioNode) {
            prev.connect(current);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(prev)) {
            connect(prev, current);
        }
        return current;
    }, first);
}
function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(srcNode), "Cannot connect from undefined node");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(dstNode), "Cannot connect to undefined node");
    if (dstNode instanceof ToneAudioNode || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(dstNode)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
    // resolve the input of the dstNode
    while(dstNode instanceof ToneAudioNode || dstNode instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(dstNode.input)) {
            dstNode = dstNode.input;
        }
    }
    while(srcNode instanceof ToneAudioNode){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(srcNode.output)) {
            srcNode = srcNode.output;
        }
    }
    // make the connection
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(dstNode)) {
        srcNode.connect(dstNode, outputNumber);
    } else {
        srcNode.connect(dstNode, outputNumber, inputNumber);
    }
}
function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    // resolve the destination node
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(dstNode)) {
        while(dstNode instanceof ToneAudioNode){
            dstNode = dstNode.input;
        }
    }
    // resolve the src node
    while(!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(srcNode)){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(srcNode.output)) {
            srcNode = srcNode.output;
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioParam"])(dstNode)) {
        srcNode.disconnect(dstNode, outputNumber);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$AdvancedTypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAudioNode"])(dstNode)) {
        srcNode.disconnect(dstNode, outputNumber, inputNumber);
    } else {
        srcNode.disconnect();
    }
}
function fanIn(...nodes) {
    const dstNode = nodes.pop();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(dstNode)) {
        nodes.forEach((node)=>connect(node, dstNode));
    }
} //# sourceMappingURL=ToneAudioNode.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Gain.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Gain",
    ()=>Gain
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
;
;
;
;
class Gain extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Gain.getDefaults(), arguments, [
            "gain",
            "units"
        ]);
        super(options);
        this.name = "Gain";
        /**
         * The wrapped GainNode.
         */ this._gainNode = this.context.createGain();
        // input = output
        this.input = this._gainNode;
        this.output = this._gainNode;
        this.gain = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            convert: options.convert,
            param: this._gainNode.gain,
            units: options.units,
            value: options.gain,
            minValue: options.minValue,
            maxValue: options.maxValue
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOnly"])(this, "gain");
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"].getDefaults(), {
            convert: true,
            gain: 1,
            units: "gain"
        });
    }
    /**
     * Clean up.
     */ dispose() {
        super.dispose();
        this._gainNode.disconnect();
        this.gain.dispose();
        return this;
    }
} //# sourceMappingURL=Gain.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/TickParam.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TickParam",
    ()=>TickParam
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
;
;
;
;
class TickParam extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(TickParam.getDefaults(), arguments, [
            "value"
        ]);
        super(options);
        this.name = "TickParam";
        /**
         * The timeline which tracks all of the automations.
         */ this._events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"](Infinity);
        /**
         * The internal holder for the multiplier value
         */ this._multiplier = 1;
        // set the multiplier
        this._multiplier = options.multiplier;
        // clear the ticks from the beginning
        this._events.cancel(0);
        // set an initial event
        this._events.add({
            ticks: 0,
            time: 0,
            type: "setValueAtTime",
            value: this._fromType(options.value)
        });
        this.setValueAtTime(options.value, 0);
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"].getDefaults(), {
            multiplier: 1,
            units: "hertz",
            value: 1
        });
    }
    setTargetAtTime(value, time, constant) {
        // approximate it with multiple linear ramps
        time = this.toSeconds(time);
        this.setRampPoint(time);
        const computedValue = this._fromType(value);
        // start from previously scheduled value
        const prevEvent = this._events.get(time);
        const segments = Math.round(Math.max(1 / constant, 1));
        for(let i = 0; i <= segments; i++){
            const segTime = constant * i + time;
            const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
            this.linearRampToValueAtTime(this._toType(rampVal), segTime);
        }
        return this;
    }
    setValueAtTime(value, time) {
        const computedTime = this.toSeconds(time);
        super.setValueAtTime(value, time);
        const event = this._events.get(computedTime);
        const previousEvent = this._events.previousEvent(event);
        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
        event.ticks = Math.max(ticksUntilTime, 0);
        return this;
    }
    linearRampToValueAtTime(value, time) {
        const computedTime = this.toSeconds(time);
        super.linearRampToValueAtTime(value, time);
        const event = this._events.get(computedTime);
        const previousEvent = this._events.previousEvent(event);
        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
        event.ticks = Math.max(ticksUntilTime, 0);
        return this;
    }
    exponentialRampToValueAtTime(value, time) {
        // aproximate it with multiple linear ramps
        time = this.toSeconds(time);
        const computedVal = this._fromType(value);
        // start from previously scheduled value
        const prevEvent = this._events.get(time);
        // approx 10 segments per second
        const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));
        const segmentDur = (time - prevEvent.time) / segments;
        for(let i = 0; i <= segments; i++){
            const segTime = segmentDur * i + prevEvent.time;
            const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);
            this.linearRampToValueAtTime(this._toType(rampVal), segTime);
        }
        return this;
    }
    /**
     * Returns the tick value at the time. Takes into account
     * any automation curves scheduled on the signal.
     * @param  event The time to get the tick count at
     * @return The number of ticks which have elapsed at the time given any automations.
     */ _getTicksUntilEvent(event, time) {
        if (event === null) {
            event = {
                ticks: 0,
                time: 0,
                type: "setValueAtTime",
                value: 0
            };
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"])(event.ticks)) {
            const previousEvent = this._events.previousEvent(event);
            event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
        }
        const val0 = this._fromType(this.getValueAtTime(event.time));
        let val1 = this._fromType(this.getValueAtTime(time));
        // if it's right on the line, take the previous value
        const onTheLineEvent = this._events.get(time);
        if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === "setValueAtTime") {
            val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));
        }
        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
    }
    /**
     * Returns the tick value at the time. Takes into account
     * any automation curves scheduled on the signal.
     * @param  time The time to get the tick count at
     * @return The number of ticks which have elapsed at the time given any automations.
     */ getTicksAtTime(time) {
        const computedTime = this.toSeconds(time);
        const event = this._events.get(computedTime);
        return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
    }
    /**
     * Return the elapsed time of the number of ticks from the given time
     * @param ticks The number of ticks to calculate
     * @param  time The time to get the next tick from
     * @return The duration of the number of ticks from the given time in seconds
     */ getDurationOfTicks(ticks, time) {
        const computedTime = this.toSeconds(time);
        const currentTick = this.getTicksAtTime(time);
        return this.getTimeOfTick(currentTick + ticks) - computedTime;
    }
    /**
     * Given a tick, returns the time that tick occurs at.
     * @return The time that the tick occurs.
     */ getTimeOfTick(tick) {
        const before = this._events.get(tick, "ticks");
        const after = this._events.getAfter(tick, "ticks");
        if (before && before.ticks === tick) {
            return before.time;
        } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
            const val0 = this._fromType(this.getValueAtTime(before.time));
            const val1 = this._fromType(this.getValueAtTime(after.time));
            const delta = (val1 - val0) / (after.time - before.time);
            const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
            const sol1 = (-val0 + k) / delta;
            const sol2 = (-val0 - k) / delta;
            return (sol1 > 0 ? sol1 : sol2) + before.time;
        } else if (before) {
            if (before.value === 0) {
                return Infinity;
            } else {
                return before.time + (tick - before.ticks) / before.value;
            }
        } else {
            return tick / this._initialValue;
        }
    }
    /**
     * Convert some number of ticks their the duration in seconds accounting
     * for any automation curves starting at the given time.
     * @param  ticks The number of ticks to convert to seconds.
     * @param  when  When along the automation timeline to convert the ticks.
     * @return The duration in seconds of the ticks.
     */ ticksToTime(ticks, when) {
        return this.getDurationOfTicks(ticks, when);
    }
    /**
     * The inverse of {@link ticksToTime}. Convert a duration in
     * seconds to the corresponding number of ticks accounting for any
     * automation curves starting at the given time.
     * @param  duration The time interval to convert to ticks.
     * @param  when When along the automation timeline to convert the ticks.
     * @return The duration in ticks.
     */ timeToTicks(duration, when) {
        const computedTime = this.toSeconds(when);
        const computedDuration = this.toSeconds(duration);
        const startTicks = this.getTicksAtTime(computedTime);
        const endTicks = this.getTicksAtTime(computedTime + computedDuration);
        return endTicks - startTicks;
    }
    /**
     * Convert from the type when the unit value is BPM
     */ _fromType(val) {
        if (this.units === "bpm" && this.multiplier) {
            return 1 / (60 / val / this.multiplier);
        } else {
            return super._fromType(val);
        }
    }
    /**
     * Special case of type conversion where the units === "bpm"
     */ _toType(val) {
        if (this.units === "bpm" && this.multiplier) {
            return val / this.multiplier * 60;
        } else {
            return super._toType(val);
        }
    }
    /**
     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
     */ get multiplier() {
        return this._multiplier;
    }
    set multiplier(m) {
        // get and reset the current value with the new multiplier
        // might be necessary to clear all the previous values
        const currentVal = this.value;
        this._multiplier = m;
        this.cancelScheduledValues(0);
        this.setValueAtTime(currentVal, 0);
    }
} //# sourceMappingURL=TickParam.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/TickSignal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TickSignal",
    ()=>TickSignal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$signal$2f$Signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/signal/Signal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickParam$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TickParam.js [app-client] (ecmascript)");
;
;
;
class TickSignal extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$signal$2f$Signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(TickSignal.getDefaults(), arguments, [
            "value"
        ]);
        super(options);
        this.name = "TickSignal";
        this.input = this._param = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickParam$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickParam"]({
            context: this.context,
            convert: options.convert,
            multiplier: options.multiplier,
            param: this._constantSource.offset,
            units: options.units,
            value: options.value
        });
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$signal$2f$Signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Signal"].getDefaults(), {
            multiplier: 1,
            units: "hertz",
            value: 1
        });
    }
    ticksToTime(ticks, when) {
        return this._param.ticksToTime(ticks, when);
    }
    timeToTicks(duration, when) {
        return this._param.timeToTicks(duration, when);
    }
    getTimeOfTick(tick) {
        return this._param.getTimeOfTick(tick);
    }
    getDurationOfTicks(ticks, time) {
        return this._param.getDurationOfTicks(ticks, time);
    }
    getTicksAtTime(time) {
        return this._param.getTicksAtTime(time);
    }
    /**
     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
     */ get multiplier() {
        return this._param.multiplier;
    }
    set multiplier(m) {
        this._param.multiplier = m;
    }
    dispose() {
        super.dispose();
        this._param.dispose();
        return this;
    }
} //# sourceMappingURL=TickSignal.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/TickSource.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TickSource",
    ()=>TickSource
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/StateTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickSignal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TickSignal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Math.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
class TickSource extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(TickSource.getDefaults(), arguments, [
            "frequency"
        ]);
        super(options);
        this.name = "TickSource";
        /**
         * The state timeline
         */ this._state = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StateTimeline"]();
        /**
         * The offset values of the ticks
         */ this._tickOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        /**
         * Memoized values of getTicksAtTime at events with state other than "started"
         */ this._ticksAtTime = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        /**
         * Memoized values of getSecondsAtTime at events with state other than "started"
         */ this._secondsAtTime = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        this.frequency = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickSignal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickSignal"]({
            context: this.context,
            units: options.units,
            value: options.frequency
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOnly"])(this, "frequency");
        // set the initial state
        this._state.setStateAtTime("stopped", 0);
        // add the first event
        this.setTicksAtTime(0, 0);
    }
    static getDefaults() {
        return Object.assign({
            frequency: 1,
            units: "hertz"
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"].getDefaults());
    }
    /**
     * Returns the playback state of the source, either "started", "stopped" or "paused".
     */ get state() {
        return this.getStateAtTime(this.now());
    }
    /**
     * Start the clock at the given time. Optionally pass in an offset
     * of where to start the tick counter from.
     * @param  time    The time the clock should start
     * @param offset The number of ticks to start the source at
     */ start(time, offset) {
        const computedTime = this.toSeconds(time);
        if (this._state.getValueAtTime(computedTime) !== "started") {
            this._state.setStateAtTime("started", computedTime);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(offset)) {
                this.setTicksAtTime(offset, computedTime);
            }
            this._ticksAtTime.cancel(computedTime);
            this._secondsAtTime.cancel(computedTime);
        }
        return this;
    }
    /**
     * Stop the clock. Stopping the clock resets the tick counter to 0.
     * @param time The time when the clock should stop.
     */ stop(time) {
        const computedTime = this.toSeconds(time);
        // cancel the previous stop
        if (this._state.getValueAtTime(computedTime) === "stopped") {
            const event = this._state.get(computedTime);
            if (event && event.time > 0) {
                this._tickOffset.cancel(event.time);
                this._state.cancel(event.time);
            }
        }
        this._state.cancel(computedTime);
        this._state.setStateAtTime("stopped", computedTime);
        this.setTicksAtTime(0, computedTime);
        this._ticksAtTime.cancel(computedTime);
        this._secondsAtTime.cancel(computedTime);
        return this;
    }
    /**
     * Pause the clock. Pausing does not reset the tick counter.
     * @param time The time when the clock should stop.
     */ pause(time) {
        const computedTime = this.toSeconds(time);
        if (this._state.getValueAtTime(computedTime) === "started") {
            this._state.setStateAtTime("paused", computedTime);
            this._ticksAtTime.cancel(computedTime);
            this._secondsAtTime.cancel(computedTime);
        }
        return this;
    }
    /**
     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
     * @param time When to clear the events after
     */ cancel(time) {
        time = this.toSeconds(time);
        this._state.cancel(time);
        this._tickOffset.cancel(time);
        this._ticksAtTime.cancel(time);
        this._secondsAtTime.cancel(time);
        return this;
    }
    /**
     * Get the elapsed ticks at the given time
     * @param  time  When to get the tick value
     * @return The number of ticks
     */ getTicksAtTime(time) {
        const computedTime = this.toSeconds(time);
        const stopEvent = this._state.getLastState("stopped", computedTime);
        // get previously memoized ticks if available
        const memoizedEvent = this._ticksAtTime.get(computedTime);
        // this event allows forEachBetween to iterate until the current time
        const tmpEvent = {
            state: "paused",
            time: computedTime
        };
        this._state.add(tmpEvent);
        // keep track of the previous offset event
        let lastState = memoizedEvent ? memoizedEvent : stopEvent;
        let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;
        let eventToMemoize = null;
        // iterate through all the events since the last stop
        this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e)=>{
            let periodStartTime = lastState.time;
            // if there is an offset event in this period use that
            const offsetEvent = this._tickOffset.get(e.time);
            if (offsetEvent && offsetEvent.time >= lastState.time) {
                elapsedTicks = offsetEvent.ticks;
                periodStartTime = offsetEvent.time;
            }
            if (lastState.state === "started" && e.state !== "started") {
                elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);
                // do not memoize the temporary event
                if (e.time !== tmpEvent.time) {
                    eventToMemoize = {
                        state: e.state,
                        time: e.time,
                        ticks: elapsedTicks
                    };
                }
            }
            lastState = e;
        });
        // remove the temporary event
        this._state.remove(tmpEvent);
        // memoize the ticks at the most recent event with state other than "started"
        if (eventToMemoize) {
            this._ticksAtTime.add(eventToMemoize);
        }
        // return the ticks
        return elapsedTicks;
    }
    /**
     * The number of times the callback was invoked. Starts counting at 0
     * and increments after the callback was invoked. Returns -1 when stopped.
     */ get ticks() {
        return this.getTicksAtTime(this.now());
    }
    set ticks(t) {
        this.setTicksAtTime(t, this.now());
    }
    /**
     * The time since ticks=0 that the TickSource has been running. Accounts
     * for tempo curves
     */ get seconds() {
        return this.getSecondsAtTime(this.now());
    }
    set seconds(s) {
        const now = this.now();
        const ticks = this.frequency.timeToTicks(s, now);
        this.setTicksAtTime(ticks, now);
    }
    /**
     * Return the elapsed seconds at the given time.
     * @param  time  When to get the elapsed seconds
     * @return  The number of elapsed seconds
     */ getSecondsAtTime(time) {
        time = this.toSeconds(time);
        const stopEvent = this._state.getLastState("stopped", time);
        // this event allows forEachBetween to iterate until the current time
        const tmpEvent = {
            state: "paused",
            time
        };
        this._state.add(tmpEvent);
        // get previously memoized seconds if available
        const memoizedEvent = this._secondsAtTime.get(time);
        // keep track of the previous offset event
        let lastState = memoizedEvent ? memoizedEvent : stopEvent;
        let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;
        let eventToMemoize = null;
        // iterate through all the events since the last stop
        this._state.forEachBetween(lastState.time, time + this.sampleTime, (e)=>{
            let periodStartTime = lastState.time;
            // if there is an offset event in this period use that
            const offsetEvent = this._tickOffset.get(e.time);
            if (offsetEvent && offsetEvent.time >= lastState.time) {
                elapsedSeconds = offsetEvent.seconds;
                periodStartTime = offsetEvent.time;
            }
            if (lastState.state === "started" && e.state !== "started") {
                elapsedSeconds += e.time - periodStartTime;
                // do not memoize the temporary event
                if (e.time !== tmpEvent.time) {
                    eventToMemoize = {
                        state: e.state,
                        time: e.time,
                        seconds: elapsedSeconds
                    };
                }
            }
            lastState = e;
        });
        // remove the temporary event
        this._state.remove(tmpEvent);
        // memoize the seconds at the most recent event with state other than "started"
        if (eventToMemoize) {
            this._secondsAtTime.add(eventToMemoize);
        }
        // return the seconds
        return elapsedSeconds;
    }
    /**
     * Set the clock's ticks at the given time.
     * @param  ticks The tick value to set
     * @param  time  When to set the tick value
     */ setTicksAtTime(ticks, time) {
        time = this.toSeconds(time);
        this._tickOffset.cancel(time);
        this._tickOffset.add({
            seconds: this.frequency.getDurationOfTicks(ticks, time),
            ticks,
            time
        });
        this._ticksAtTime.cancel(time);
        this._secondsAtTime.cancel(time);
        return this;
    }
    /**
     * Returns the scheduled state at the given time.
     * @param  time  The time to query.
     */ getStateAtTime(time) {
        time = this.toSeconds(time);
        return this._state.getValueAtTime(time);
    }
    /**
     * Get the time of the given tick. The second argument
     * is when to test before. Since ticks can be set (with setTicksAtTime)
     * there may be multiple times for a given tick value.
     * @param  tick The tick number.
     * @param  before When to measure the tick value from.
     * @return The time of the tick
     */ getTimeOfTick(tick, before = this.now()) {
        const offset = this._tickOffset.get(before);
        const event = this._state.get(before);
        const startTime = Math.max(offset.time, event.time);
        const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
        return this.frequency.getTimeOfTick(absoluteTicks);
    }
    /**
     * Invoke the callback event at all scheduled ticks between the
     * start time and the end time
     * @param  startTime  The beginning of the search range
     * @param  endTime    The end of the search range
     * @param  callback   The callback to invoke with each tick
     */ forEachTickBetween(startTime, endTime, callback) {
        // only iterate through the sections where it is "started"
        let lastStateEvent = this._state.get(startTime);
        this._state.forEachBetween(startTime, endTime, (event)=>{
            if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
                this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
            }
            lastStateEvent = event;
        });
        let error = null;
        if (lastStateEvent && lastStateEvent.state === "started") {
            const maxStartTime = Math.max(lastStateEvent.time, startTime);
            // figure out the difference between the frequency ticks and the
            const startTicks = this.frequency.getTicksAtTime(maxStartTime);
            const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
            const diff = startTicks - ticksAtStart;
            let offset = Math.ceil(diff) - diff;
            // guard against floating point issues
            offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EQ"])(offset, 1) ? 0 : offset;
            let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);
            while(nextTickTime < endTime){
                try {
                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
                } catch (e) {
                    error = e;
                    break;
                }
                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
            }
        }
        if (error) {
            throw error;
        }
        return this;
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        this._state.dispose();
        this._tickOffset.dispose();
        this._ticksAtTime.dispose();
        this._secondsAtTime.dispose();
        this.frequency.dispose();
        return this;
    }
} //# sourceMappingURL=TickSource.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/Clock.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Clock",
    ()=>Clock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/StateTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TickSource.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
class Clock extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Clock.getDefaults(), arguments, [
            "callback",
            "frequency"
        ]);
        super(options);
        this.name = "Clock";
        /**
         * The callback function to invoke at the scheduled tick.
         */ this.callback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"];
        /**
         * The last time the loop callback was invoked
         */ this._lastUpdate = 0;
        /**
         * Keep track of the playback state
         */ this._state = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StateTimeline"]("stopped");
        /**
         * Context bound reference to the _loop method
         * This is necessary to remove the event in the end.
         */ this._boundLoop = this._loop.bind(this);
        this.callback = options.callback;
        this._tickSource = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TickSource$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TickSource"]({
            context: this.context,
            frequency: options.frequency,
            units: options.units
        });
        this._lastUpdate = 0;
        this.frequency = this._tickSource.frequency;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOnly"])(this, "frequency");
        // add an initial state
        this._state.setStateAtTime("stopped", 0);
        // bind a callback to the worker thread
        this.context.on("tick", this._boundLoop);
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"].getDefaults(), {
            callback: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            frequency: 1,
            units: "hertz"
        });
    }
    /**
     * Returns the playback state of the source, either "started", "stopped" or "paused".
     */ get state() {
        return this._state.getValueAtTime(this.now());
    }
    /**
     * Start the clock at the given time. Optionally pass in an offset
     * of where to start the tick counter from.
     * @param  time    The time the clock should start
     * @param offset  Where the tick counter starts counting from.
     */ start(time, offset) {
        // make sure the context is running
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertContextRunning"])(this.context);
        // start the loop
        const computedTime = this.toSeconds(time);
        this.log("start", computedTime);
        if (this._state.getValueAtTime(computedTime) !== "started") {
            this._state.setStateAtTime("started", computedTime);
            this._tickSource.start(computedTime, offset);
            if (computedTime < this._lastUpdate) {
                this.emit("start", computedTime, offset);
            }
        }
        return this;
    }
    /**
     * Stop the clock. Stopping the clock resets the tick counter to 0.
     * @param time The time when the clock should stop.
     * @example
     * const clock = new Tone.Clock(time => {
     * 	console.log(time);
     * }, 1);
     * clock.start();
     * // stop the clock after 10 seconds
     * clock.stop("+10");
     */ stop(time) {
        const computedTime = this.toSeconds(time);
        this.log("stop", computedTime);
        this._state.cancel(computedTime);
        this._state.setStateAtTime("stopped", computedTime);
        this._tickSource.stop(computedTime);
        if (computedTime < this._lastUpdate) {
            this.emit("stop", computedTime);
        }
        return this;
    }
    /**
     * Pause the clock. Pausing does not reset the tick counter.
     * @param time The time when the clock should stop.
     */ pause(time) {
        const computedTime = this.toSeconds(time);
        if (this._state.getValueAtTime(computedTime) === "started") {
            this._state.setStateAtTime("paused", computedTime);
            this._tickSource.pause(computedTime);
            if (computedTime < this._lastUpdate) {
                this.emit("pause", computedTime);
            }
        }
        return this;
    }
    /**
     * The number of times the callback was invoked. Starts counting at 0
     * and increments after the callback was invoked.
     */ get ticks() {
        return Math.ceil(this.getTicksAtTime(this.now()));
    }
    set ticks(t) {
        this._tickSource.ticks = t;
    }
    /**
     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
     */ get seconds() {
        return this._tickSource.seconds;
    }
    set seconds(s) {
        this._tickSource.seconds = s;
    }
    /**
     * Return the elapsed seconds at the given time.
     * @param  time  When to get the elapsed seconds
     * @return  The number of elapsed seconds
     */ getSecondsAtTime(time) {
        return this._tickSource.getSecondsAtTime(time);
    }
    /**
     * Set the clock's ticks at the given time.
     * @param  ticks The tick value to set
     * @param  time  When to set the tick value
     */ setTicksAtTime(ticks, time) {
        this._tickSource.setTicksAtTime(ticks, time);
        return this;
    }
    /**
     * Get the time of the given tick. The second argument
     * is when to test before. Since ticks can be set (with setTicksAtTime)
     * there may be multiple times for a given tick value.
     * @param  tick The tick number.
     * @param  before When to measure the tick value from.
     * @return The time of the tick
     */ getTimeOfTick(tick, before = this.now()) {
        return this._tickSource.getTimeOfTick(tick, before);
    }
    /**
     * Get the clock's ticks at the given time.
     * @param  time  When to get the tick value
     * @return The tick value at the given time.
     */ getTicksAtTime(time) {
        return this._tickSource.getTicksAtTime(time);
    }
    /**
     * Get the time of the next tick
     * @param  offset The tick number.
     */ nextTickTime(offset, when) {
        const computedTime = this.toSeconds(when);
        const currentTick = this.getTicksAtTime(computedTime);
        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
    }
    /**
     * The scheduling loop.
     */ _loop() {
        const startTime = this._lastUpdate;
        const endTime = this.now();
        this._lastUpdate = endTime;
        this.log("loop", startTime, endTime);
        if (startTime !== endTime) {
            // the state change events
            this._state.forEachBetween(startTime, endTime, (e)=>{
                switch(e.state){
                    case "started":
                        const offset = this._tickSource.getTicksAtTime(e.time);
                        this.emit("start", e.time, offset);
                        break;
                    case "stopped":
                        if (e.time !== 0) {
                            this.emit("stop", e.time);
                        }
                        break;
                    case "paused":
                        this.emit("pause", e.time);
                        break;
                }
            });
            // the tick callbacks
            this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks)=>{
                this.callback(time, ticks);
            });
        }
    }
    /**
     * Returns the scheduled state at the given time.
     * @param  time  The time to query.
     * @return  The name of the state input in setStateAtTime.
     * @example
     * const clock = new Tone.Clock();
     * clock.start("+0.1");
     * clock.getStateAtTime("+0.1"); // returns "started"
     */ getStateAtTime(time) {
        const computedTime = this.toSeconds(time);
        return this._state.getValueAtTime(computedTime);
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        this.context.off("tick", this._boundLoop);
        this._tickSource.dispose();
        this._state.dispose();
        return this;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Emitter"].mixin(Clock); //# sourceMappingURL=Clock.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Delay.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Delay",
    ()=>Delay
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
;
;
;
;
class Delay extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(Delay.getDefaults(), arguments, [
            "delayTime",
            "maxDelay"
        ]);
        super(options);
        this.name = "Delay";
        const maxDelayInSeconds = this.toSeconds(options.maxDelay);
        this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));
        this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
        this.delayTime = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this._delayNode.delayTime,
            units: "time",
            value: options.delayTime,
            minValue: 0,
            maxValue: this.maxDelay
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOnly"])(this, "delayTime");
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"].getDefaults(), {
            delayTime: 0,
            maxDelay: 1
        });
    }
    /**
     * The maximum delay time. This cannot be changed after
     * the value is passed into the constructor.
     */ get maxDelay() {
        return this._maxDelay;
    }
    /**
     * Clean up.
     */ dispose() {
        super.dispose();
        this._delayNode.disconnect();
        this.delayTime.dispose();
        return this;
    }
} //# sourceMappingURL=Delay.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Destination.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DestinationClass",
    ()=>DestinationClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$component$2f$channel$2f$Volume$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/component/channel/Volume.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Gain.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
;
;
;
;
;
class DestinationClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(DestinationClass.getDefaults(), arguments);
        super(options);
        this.name = "Destination";
        this.input = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$component$2f$channel$2f$Volume$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Volume"]({
            context: this.context
        });
        this.output = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Gain"]({
            context: this.context
        });
        /**
         * The volume of the master output in decibels. -Infinity is silent, and 0 is no change.
         * @example
         * const osc = new Tone.Oscillator().toDestination();
         * osc.start();
         * // ramp the volume down to silent over 10 seconds
         * Tone.getDestination().volume.rampTo(-Infinity, 10);
         */ this.volume = this.input.volume;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connectSeries"])(this.input, this.output, this.context.rawContext.destination);
        this.mute = options.mute;
        this._internalChannels = [
            this.input,
            this.context.rawContext.destination,
            this.output
        ];
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"].getDefaults(), {
            mute: false,
            volume: 0
        });
    }
    /**
     * Mute the output.
     * @example
     * const oscillator = new Tone.Oscillator().start().toDestination();
     * setTimeout(() => {
     * 	// mute the output
     * 	Tone.Destination.mute = true;
     * }, 1000);
     */ get mute() {
        return this.input.mute;
    }
    set mute(mute) {
        this.input.mute = mute;
    }
    /**
     * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
     * chained in the master effects chain.
     * @param args All arguments will be connected in a row and the Master will be routed through it.
     * @example
     * // route all audio through a filter and compressor
     * const lowpass = new Tone.Filter(800, "lowpass");
     * const compressor = new Tone.Compressor(-18);
     * Tone.Destination.chain(lowpass, compressor);
     */ chain(...args) {
        this.input.disconnect();
        args.unshift(this.input);
        args.push(this.output);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connectSeries"])(...args);
        return this;
    }
    /**
     * The maximum number of channels the system can output
     * @example
     * console.log(Tone.Destination.maxChannelCount);
     */ get maxChannelCount() {
        return this.context.rawContext.destination.maxChannelCount;
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        this.volume.dispose();
        return this;
    }
}
//-------------------------------------
// 	INITIALIZATION
//-------------------------------------
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextInit"])((context)=>{
    context.destination = new DestinationClass({
        context
    });
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextClose"])((context)=>{
    context.destination.dispose();
}); //# sourceMappingURL=Destination.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Listener.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ListenerClass",
    ()=>ListenerClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)");
;
;
;
class ListenerClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"] {
    constructor(){
        super(...arguments);
        this.name = "Listener";
        this.positionX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.positionX
        });
        this.positionY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.positionY
        });
        this.positionZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.positionZ
        });
        this.forwardX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.forwardX
        });
        this.forwardY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.forwardY
        });
        this.forwardZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.forwardZ
        });
        this.upX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.upX
        });
        this.upY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.upY
        });
        this.upZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"]({
            context: this.context,
            param: this.context.rawContext.listener.upZ
        });
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"].getDefaults(), {
            positionX: 0,
            positionY: 0,
            positionZ: 0,
            forwardX: 0,
            forwardY: 0,
            forwardZ: -1,
            upX: 0,
            upY: 1,
            upZ: 0
        });
    }
    dispose() {
        super.dispose();
        this.positionX.dispose();
        this.positionY.dispose();
        this.positionZ.dispose();
        this.forwardX.dispose();
        this.forwardY.dispose();
        this.forwardZ.dispose();
        this.upX.dispose();
        this.upY.dispose();
        this.upZ.dispose();
        return this;
    }
}
//-------------------------------------
// 	INITIALIZATION
//-------------------------------------
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextInit"])((context)=>{
    context.listener = new ListenerClass({
        context
    });
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextClose"])((context)=>{
    context.listener.dispose();
}); //# sourceMappingURL=Listener.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/Offline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Offline",
    ()=>Offline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/OfflineContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Destination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Destination.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Listener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Listener.js [app-client] (ecmascript)");
;
;
;
;
;
;
function Offline(callback_1, duration_1) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__awaiter"])(this, arguments, void 0, function*(callback, duration, channels = 2, sampleRate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])().sampleRate) {
        // set the OfflineAudioContext based on the current context
        const originalContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])();
        const context = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OfflineContext"](channels, duration, sampleRate);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setContext"])(context);
        // invoke the callback/scheduling
        yield callback(context);
        // then render the audio
        const bufferPromise = context.render();
        // return the original AudioContext
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setContext"])(originalContext);
        // await the rendering
        const buffer = yield bufferPromise;
        // return the audio
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffer"](buffer);
    });
} //# sourceMappingURL=Offline.js.map
}),
"[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToneAudioBuffers",
    ()=>ToneAudioBuffers
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
class ToneAudioBuffers extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super();
        this.name = "ToneAudioBuffers";
        /**
         * All of the buffers
         */ this._buffers = new Map();
        /**
         * Keep track of the number of loaded buffers
         */ this._loadingCount = 0;
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(ToneAudioBuffers.getDefaults(), arguments, [
            "urls",
            "onload",
            "baseUrl"
        ], "urls");
        this.baseUrl = options.baseUrl;
        // add each one
        Object.keys(options.urls).forEach((name)=>{
            this._loadingCount++;
            const url = options.urls[name];
            this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);
        });
    }
    static getDefaults() {
        return {
            baseUrl: "",
            onerror: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            onload: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            urls: {}
        };
    }
    /**
     * True if the buffers object has a buffer by that name.
     * @param  name  The key or index of the buffer.
     */ has(name) {
        return this._buffers.has(name.toString());
    }
    /**
     * Get a buffer by name. If an array was loaded,
     * then use the array index.
     * @param  name  The key or index of the buffer.
     */ get(name) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);
        return this._buffers.get(name.toString());
    }
    /**
     * A buffer was loaded. decrement the counter.
     */ _bufferLoaded(callback) {
        this._loadingCount--;
        if (this._loadingCount === 0 && callback) {
            callback();
        }
    }
    /**
     * If the buffers are loaded or not
     */ get loaded() {
        return Array.from(this._buffers).every(([_, buffer])=>buffer.loaded);
    }
    /**
     * Add a buffer by name and url to the Buffers
     * @param  name      A unique name to give the buffer
     * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
     * @param  callback  The callback to invoke when the url is loaded.
     * @param  onerror  Invoked if the buffer can't be loaded
     */ add(name, url, callback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"], onerror = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"]) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(url)) {
            // don't include the baseUrl if the url is a base64 encoded sound
            if (this.baseUrl && url.trim().substring(0, 11).toLowerCase() === "data:audio/") {
                this.baseUrl = "";
            }
            this._buffers.set(name.toString(), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffer"](this.baseUrl + url, callback, onerror));
        } else {
            this._buffers.set(name.toString(), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffer"](url, callback, onerror));
        }
        return this;
    }
    dispose() {
        super.dispose();
        this._buffers.forEach((buffer)=>buffer.dispose());
        this._buffers.clear();
        return this;
    }
} //# sourceMappingURL=ToneAudioBuffers.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Midi.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Midi",
    ()=>Midi,
    "MidiClass",
    ()=>MidiClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Frequency.js [app-client] (ecmascript)");
;
;
;
class MidiClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrequencyClass"] {
    constructor(){
        super(...arguments);
        this.name = "MidiClass";
        this.defaultUnits = "midi";
    }
    /**
     * Returns the value of a frequency in the current units
     */ _frequencyToUnits(freq) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(super._frequencyToUnits(freq));
    }
    /**
     * Returns the value of a tick in the current time units
     */ _ticksToUnits(ticks) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(super._ticksToUnits(ticks));
    }
    /**
     * Return the value of the beats in the current units
     */ _beatsToUnits(beats) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(super._beatsToUnits(beats));
    }
    /**
     * Returns the value of a second in the current units
     */ _secondsToUnits(seconds) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"])(super._secondsToUnits(seconds));
    }
    /**
     * Return the value of the frequency as a MIDI note
     * @example
     * Tone.Midi(60).toMidi(); // 60
     */ toMidi() {
        return this.valueOf();
    }
    /**
     * Return the value of the frequency as a MIDI note
     * @example
     * Tone.Midi(60).toFrequency(); // 261.6255653005986
     */ toFrequency() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mtof"])(this.toMidi());
    }
    /**
     * Transposes the frequency by the given number of semitones.
     * @return A new transposed MidiClass
     * @example
     * Tone.Midi("A4").transpose(3); // "C5"
     */ transpose(interval) {
        return new MidiClass(this.context, this.toMidi() + interval);
    }
}
function Midi(value, units) {
    return new MidiClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])(), value, units);
} //# sourceMappingURL=Midi.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Ticks.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Ticks",
    ()=>Ticks,
    "TicksClass",
    ()=>TicksClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Global.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)");
;
;
class TicksClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"] {
    constructor(){
        super(...arguments);
        this.name = "Ticks";
        this.defaultUnits = "i";
    }
    /**
     * Get the current time in the given units
     */ _now() {
        return this.context.transport.ticks;
    }
    /**
     * Return the value of the beats in the current units
     */ _beatsToUnits(beats) {
        return this._getPPQ() * beats;
    }
    /**
     * Returns the value of a second in the current units
     */ _secondsToUnits(seconds) {
        return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
    }
    /**
     * Returns the value of a tick in the current time units
     */ _ticksToUnits(ticks) {
        return ticks;
    }
    /**
     * Return the time in ticks
     */ toTicks() {
        return this.valueOf();
    }
    /**
     * Return the time in seconds
     */ toSeconds() {
        return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
    }
}
function Ticks(value, units) {
    return new TicksClass((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Global$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContext"])(), value, units);
} //# sourceMappingURL=Ticks.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Draw.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DrawClass",
    ()=>DrawClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)");
;
;
;
class DrawClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        super(...arguments);
        this.name = "Draw";
        /**
         * The duration after which events are not invoked.
         */ this.expiration = 0.25;
        /**
         * The amount of time before the scheduled time
         * that the callback can be invoked. Default is
         * half the time of an animation frame (0.008 seconds).
         */ this.anticipation = 0.008;
        /**
         * All of the events.
         */ this._events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        /**
         * The draw loop
         */ this._boundDrawLoop = this._drawLoop.bind(this);
        /**
         * The animation frame id
         */ this._animationFrame = -1;
    }
    /**
     * Schedule a function at the given time to be invoked
     * on the nearest animation frame.
     * @param  callback  Callback is invoked at the given time.
     * @param  time      The time relative to the AudioContext time to invoke the callback.
     * @example
     * Tone.Transport.scheduleRepeat(time => {
     * 	Tone.Draw.schedule(() => console.log(time), time);
     * }, 1);
     * Tone.Transport.start();
     */ schedule(callback, time) {
        this._events.add({
            callback,
            time: this.toSeconds(time)
        });
        // start the draw loop on the first event
        if (this._events.length === 1) {
            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
        }
        return this;
    }
    /**
     * Cancel events scheduled after the given time
     * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
     */ cancel(after) {
        this._events.cancel(this.toSeconds(after));
        return this;
    }
    /**
     * The draw loop
     */ _drawLoop() {
        const now = this.context.currentTime;
        this._events.forEachBefore(now + this.anticipation, (event)=>{
            if (now - event.time <= this.expiration) {
                event.callback();
            }
            this._events.remove(event);
        });
        if (this._events.length > 0) {
            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
        }
    }
    dispose() {
        super.dispose();
        this._events.dispose();
        cancelAnimationFrame(this._animationFrame);
        return this;
    }
}
//-------------------------------------
// 	INITIALIZATION
//-------------------------------------
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextInit"])((context)=>{
    context.draw = new DrawClass({
        context
    });
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextClose"])((context)=>{
    context.draw.dispose();
}); //# sourceMappingURL=Draw.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/IntervalTimeline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IntervalTimeline",
    ()=>IntervalTimeline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
class IntervalTimeline extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    constructor(){
        super(...arguments);
        this.name = "IntervalTimeline";
        /**
         * The root node of the inteval tree
         */ this._root = null;
        /**
         * Keep track of the length of the timeline.
         */ this._length = 0;
    }
    /**
     * The event to add to the timeline. All events must
     * have a time and duration value
     * @param  event  The event to add to the timeline
     */ add(event) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(event.time), "Events must have a time property");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(event.duration), "Events must have a duration parameter");
        event.time = event.time.valueOf();
        let node = new IntervalNode(event.time, event.time + event.duration, event);
        if (this._root === null) {
            this._root = node;
        } else {
            this._root.insert(node);
        }
        this._length++;
        // Restructure tree to be balanced
        while(node !== null){
            node.updateHeight();
            node.updateMax();
            this._rebalance(node);
            node = node.parent;
        }
        return this;
    }
    /**
     * Remove an event from the timeline.
     * @param  event  The event to remove from the timeline
     */ remove(event) {
        if (this._root !== null) {
            const results = [];
            this._root.search(event.time, results);
            for (const node of results){
                if (node.event === event) {
                    this._removeNode(node);
                    this._length--;
                    break;
                }
            }
        }
        return this;
    }
    /**
     * The number of items in the timeline.
     * @readOnly
     */ get length() {
        return this._length;
    }
    /**
     * Remove events whose time time is after the given time
     * @param  after  The time to query.
     */ cancel(after) {
        this.forEachFrom(after, (event)=>this.remove(event));
        return this;
    }
    /**
     * Set the root node as the given node
     */ _setRoot(node) {
        this._root = node;
        if (this._root !== null) {
            this._root.parent = null;
        }
    }
    /**
     * Replace the references to the node in the node's parent
     * with the replacement node.
     */ _replaceNodeInParent(node, replacement) {
        if (node.parent !== null) {
            if (node.isLeftChild()) {
                node.parent.left = replacement;
            } else {
                node.parent.right = replacement;
            }
            this._rebalance(node.parent);
        } else {
            this._setRoot(replacement);
        }
    }
    /**
     * Remove the node from the tree and replace it with
     * a successor which follows the schema.
     */ _removeNode(node) {
        if (node.left === null && node.right === null) {
            this._replaceNodeInParent(node, null);
        } else if (node.right === null) {
            this._replaceNodeInParent(node, node.left);
        } else if (node.left === null) {
            this._replaceNodeInParent(node, node.right);
        } else {
            const balance = node.getBalance();
            let replacement;
            let temp = null;
            if (balance > 0) {
                if (node.left.right === null) {
                    replacement = node.left;
                    replacement.right = node.right;
                    temp = replacement;
                } else {
                    replacement = node.left.right;
                    while(replacement.right !== null){
                        replacement = replacement.right;
                    }
                    if (replacement.parent) {
                        replacement.parent.right = replacement.left;
                        temp = replacement.parent;
                        replacement.left = node.left;
                        replacement.right = node.right;
                    }
                }
            } else if (node.right.left === null) {
                replacement = node.right;
                replacement.left = node.left;
                temp = replacement;
            } else {
                replacement = node.right.left;
                while(replacement.left !== null){
                    replacement = replacement.left;
                }
                if (replacement.parent) {
                    replacement.parent.left = replacement.right;
                    temp = replacement.parent;
                    replacement.left = node.left;
                    replacement.right = node.right;
                }
            }
            if (node.parent !== null) {
                if (node.isLeftChild()) {
                    node.parent.left = replacement;
                } else {
                    node.parent.right = replacement;
                }
            } else {
                this._setRoot(replacement);
            }
            if (temp) {
                this._rebalance(temp);
            }
        }
        node.dispose();
    }
    /**
     * Rotate the tree to the left
     */ _rotateLeft(node) {
        const parent = node.parent;
        const isLeftChild = node.isLeftChild();
        // Make node.right the new root of this sub tree (instead of node)
        const pivotNode = node.right;
        if (pivotNode) {
            node.right = pivotNode.left;
            pivotNode.left = node;
        }
        if (parent !== null) {
            if (isLeftChild) {
                parent.left = pivotNode;
            } else {
                parent.right = pivotNode;
            }
        } else {
            this._setRoot(pivotNode);
        }
    }
    /**
     * Rotate the tree to the right
     */ _rotateRight(node) {
        const parent = node.parent;
        const isLeftChild = node.isLeftChild();
        // Make node.left the new root of this sub tree (instead of node)
        const pivotNode = node.left;
        if (pivotNode) {
            node.left = pivotNode.right;
            pivotNode.right = node;
        }
        if (parent !== null) {
            if (isLeftChild) {
                parent.left = pivotNode;
            } else {
                parent.right = pivotNode;
            }
        } else {
            this._setRoot(pivotNode);
        }
    }
    /**
     * Balance the BST
     */ _rebalance(node) {
        const balance = node.getBalance();
        if (balance > 1 && node.left) {
            if (node.left.getBalance() < 0) {
                this._rotateLeft(node.left);
            } else {
                this._rotateRight(node);
            }
        } else if (balance < -1 && node.right) {
            if (node.right.getBalance() > 0) {
                this._rotateRight(node.right);
            } else {
                this._rotateLeft(node);
            }
        }
    }
    /**
     * Get an event whose time and duration span the give time. Will
     * return the match whose "time" value is closest to the given time.
     * @return  The event which spans the desired time
     */ get(time) {
        if (this._root !== null) {
            const results = [];
            this._root.search(time, results);
            if (results.length > 0) {
                let max = results[0];
                for(let i = 1; i < results.length; i++){
                    if (results[i].low > max.low) {
                        max = results[i];
                    }
                }
                return max.event;
            }
        }
        return null;
    }
    /**
     * Iterate over everything in the timeline.
     * @param  callback The callback to invoke with every item
     */ forEach(callback) {
        if (this._root !== null) {
            const allNodes = [];
            this._root.traverse((node)=>allNodes.push(node));
            allNodes.forEach((node)=>{
                if (node.event) {
                    callback(node.event);
                }
            });
        }
        return this;
    }
    /**
     * Iterate over everything in the array in which the given time
     * overlaps with the time and duration time of the event.
     * @param  time The time to check if items are overlapping
     * @param  callback The callback to invoke with every item
     */ forEachAtTime(time, callback) {
        if (this._root !== null) {
            const results = [];
            this._root.search(time, results);
            results.forEach((node)=>{
                if (node.event) {
                    callback(node.event);
                }
            });
        }
        return this;
    }
    /**
     * Iterate over everything in the array in which the time is greater
     * than or equal to the given time.
     * @param  time The time to check if items are before
     * @param  callback The callback to invoke with every item
     */ forEachFrom(time, callback) {
        if (this._root !== null) {
            const results = [];
            this._root.searchAfter(time, results);
            results.forEach((node)=>{
                if (node.event) {
                    callback(node.event);
                }
            });
        }
        return this;
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        if (this._root !== null) {
            this._root.traverse((node)=>node.dispose());
        }
        this._root = null;
        return this;
    }
}
//-------------------------------------
// 	INTERVAL NODE HELPER
//-------------------------------------
/**
 * Represents a node in the binary search tree, with the addition
 * of a "high" value which keeps track of the highest value of
 * its children.
 * References:
 * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
 * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
 * @param low
 * @param high
 */ class IntervalNode {
    constructor(low, high, event){
        // the nodes to the left
        this._left = null;
        // the nodes to the right
        this._right = null;
        // the parent node
        this.parent = null;
        // the number of child nodes
        this.height = 0;
        this.event = event;
        // the low value
        this.low = low;
        // the high value
        this.high = high;
        // the high value for this and all child nodes
        this.max = this.high;
    }
    /**
     * Insert a node into the correct spot in the tree
     */ insert(node) {
        if (node.low <= this.low) {
            if (this.left === null) {
                this.left = node;
            } else {
                this.left.insert(node);
            }
        } else if (this.right === null) {
            this.right = node;
        } else {
            this.right.insert(node);
        }
    }
    /**
     * Search the tree for nodes which overlap
     * with the given point
     * @param  point  The point to query
     * @param  results  The array to put the results
     */ search(point, results) {
        // If p is to the right of the rightmost point of any interval
        // in this node and all children, there won't be any matches.
        if (point > this.max) {
            return;
        }
        // Search left children
        if (this.left !== null) {
            this.left.search(point, results);
        }
        // Check this node
        if (this.low <= point && this.high > point) {
            results.push(this);
        }
        // If p is to the left of the time of this interval,
        // then it can't be in any child to the right.
        if (this.low > point) {
            return;
        }
        // Search right children
        if (this.right !== null) {
            this.right.search(point, results);
        }
    }
    /**
     * Search the tree for nodes which are less
     * than the given point
     * @param  point  The point to query
     * @param  results  The array to put the results
     */ searchAfter(point, results) {
        // Check this node
        if (this.low >= point) {
            results.push(this);
            if (this.left !== null) {
                this.left.searchAfter(point, results);
            }
        }
        // search the right side
        if (this.right !== null) {
            this.right.searchAfter(point, results);
        }
    }
    /**
     * Invoke the callback on this element and both it's branches
     * @param  {Function}  callback
     */ traverse(callback) {
        callback(this);
        if (this.left !== null) {
            this.left.traverse(callback);
        }
        if (this.right !== null) {
            this.right.traverse(callback);
        }
    }
    /**
     * Update the height of the node
     */ updateHeight() {
        if (this.left !== null && this.right !== null) {
            this.height = Math.max(this.left.height, this.right.height) + 1;
        } else if (this.right !== null) {
            this.height = this.right.height + 1;
        } else if (this.left !== null) {
            this.height = this.left.height + 1;
        } else {
            this.height = 0;
        }
    }
    /**
     * Update the height of the node
     */ updateMax() {
        this.max = this.high;
        if (this.left !== null) {
            this.max = Math.max(this.max, this.left.max);
        }
        if (this.right !== null) {
            this.max = Math.max(this.max, this.right.max);
        }
    }
    /**
     * The balance is how the leafs are distributed on the node
     * @return  Negative numbers are balanced to the right
     */ getBalance() {
        let balance = 0;
        if (this.left !== null && this.right !== null) {
            balance = this.left.height - this.right.height;
        } else if (this.left !== null) {
            balance = this.left.height + 1;
        } else if (this.right !== null) {
            balance = -(this.right.height + 1);
        }
        return balance;
    }
    /**
     * @returns true if this node is the left child of its parent
     */ isLeftChild() {
        return this.parent !== null && this.parent.left === this;
    }
    /**
     * get/set the left node
     */ get left() {
        return this._left;
    }
    set left(node) {
        this._left = node;
        if (node !== null) {
            node.parent = this;
        }
        this.updateHeight();
        this.updateMax();
    }
    /**
     * get/set the right node
     */ get right() {
        return this._right;
    }
    set right(node) {
        this._right = node;
        if (node !== null) {
            node.parent = this;
        }
        this.updateHeight();
        this.updateMax();
    }
    /**
     * null out references.
     */ dispose() {
        this.parent = null;
        this._left = null;
        this._right = null;
        this.event = null;
    }
} //# sourceMappingURL=IntervalTimeline.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/NoteUnits.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// This file contains all of the valid note names for all pitches between C-4 and C11
__turbopack_context__.s([]);
;
 //# sourceMappingURL=NoteUnits.js.map
}),
"[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$NoteUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/NoteUnits.js [app-client] (ecmascript)"); //# sourceMappingURL=Units.js.map
;
}),
"[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Units$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$NoteUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/NoteUnits.js [app-client] (ecmascript)");
}),
"[project]/node_modules/tone/build/esm/core/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Clock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/Clock.js [app-client] (ecmascript)");
// export * from "./clock/Transport";
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/BaseContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Delay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Delay.js [app-client] (ecmascript)");
// export * from "./context/Destination";
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Gain.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Offline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Offline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/OfflineContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Frequency.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Midi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Midi.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Draw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Draw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$IntervalTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/IntervalTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/StateTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
// get the units and export them under the "Unit" namespace
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Units$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Units$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript)");
// export the debug stuff as Debug
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/TimelineValue.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TimelineValue",
    ()=>TimelineValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/Tone.js [app-client] (ecmascript)");
;
;
class TimelineValue extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$Tone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tone"] {
    /**
     * @param initialValue The value to return if there is no scheduled values
     */ constructor(initialValue){
        super();
        this.name = "TimelineValue";
        /**
         * The timeline which stores the values
         */ this._timeline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]({
            memory: 10
        });
        this._initialValue = initialValue;
    }
    /**
     * Set the value at the given time
     */ set(value, time) {
        this._timeline.add({
            value,
            time
        });
        return this;
    }
    /**
     * Get the value at the given time
     */ get(time) {
        const event = this._timeline.get(time);
        if (event) {
            return event.value;
        } else {
            return this._initialValue;
        }
    }
} //# sourceMappingURL=TimelineValue.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/TransportEvent.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransportEvent",
    ()=>TransportEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
;
class TransportEvent {
    /**
     * @param transport The transport object which the event belongs to
     */ constructor(transport, opts){
        /**
         * The unique id of the event
         */ this.id = TransportEvent._eventId++;
        /**
         * The remaining value between the passed in time, and Math.floor(time).
         * This value is later added back when scheduling to get sub-tick precision.
         */ this._remainderTime = 0;
        const options = Object.assign(TransportEvent.getDefaults(), opts);
        this.transport = transport;
        this.callback = options.callback;
        this._once = options.once;
        this.time = Math.floor(options.time);
        this._remainderTime = options.time - this.time;
    }
    static getDefaults() {
        return {
            callback: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"],
            once: false,
            time: 0
        };
    }
    /**
     * Get the time and remainder time.
     */ get floatTime() {
        return this.time + this._remainderTime;
    }
    /**
     * Invoke the event callback.
     * @param  time  The AudioContext time in seconds of the event
     */ invoke(time) {
        if (this.callback) {
            const tickDuration = this.transport.bpm.getDurationOfTicks(1, time);
            this.callback(time + this._remainderTime * tickDuration);
            if (this._once) {
                this.transport.clear(this.id);
            }
        }
    }
    /**
     * Clean up
     */ dispose() {
        this.callback = undefined;
        return this;
    }
}
/**
 * Current ID counter
 */ TransportEvent._eventId = 0; //# sourceMappingURL=TransportEvent.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransportRepeatEvent",
    ()=>TransportRepeatEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TransportEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Math.js [app-client] (ecmascript)");
;
;
;
class TransportRepeatEvent extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportEvent"] {
    /**
     * @param transport The transport object which the event belongs to
     */ constructor(transport, opts){
        super(transport, opts);
        /**
         * The ID of the current timeline event
         */ this._currentId = -1;
        /**
         * The ID of the next timeline event
         */ this._nextId = -1;
        /**
         * The time of the next event
         */ this._nextTick = this.time;
        /**
         * a reference to the bound start method
         */ this._boundRestart = this._restart.bind(this);
        const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);
        this.duration = options.duration;
        this._interval = options.interval;
        this._nextTick = options.time;
        this.transport.on("start", this._boundRestart);
        this.transport.on("loopStart", this._boundRestart);
        this.transport.on("ticks", this._boundRestart);
        this.context = this.transport.context;
        this._restart();
    }
    static getDefaults() {
        return Object.assign({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportEvent"].getDefaults(), {
            duration: Infinity,
            interval: 1,
            once: false
        });
    }
    /**
     * Invoke the callback. Returns the tick time which
     * the next event should be scheduled at.
     * @param  time  The AudioContext time in seconds of the event
     */ invoke(time) {
        // create more events if necessary
        this._createEvents(time);
        // call the super class
        super.invoke(time);
    }
    /**
     * Create an event on the transport on the nextTick
     */ _createEvent() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LT"])(this._nextTick, this.floatTime + this.duration)) {
            return this.transport.scheduleOnce(this.invoke.bind(this), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, this._nextTick).toSeconds());
        }
        return -1;
    }
    /**
     * Push more events onto the timeline to keep up with the position of the timeline
     */ _createEvents(time) {
        // schedule the next event
        // const ticks = this.transport.getTicksAtTime(time);
        // if the next tick is within the bounds set by "duration"
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LT"])(this._nextTick + this._interval, this.floatTime + this.duration)) {
            this._nextTick += this._interval;
            this._currentId = this._nextId;
            this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, this._nextTick).toSeconds());
        }
    }
    /**
     * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
     */ _restart(time) {
        this.transport.clear(this._currentId);
        this.transport.clear(this._nextId);
        // start at the first event
        this._nextTick = this.floatTime;
        const ticks = this.transport.getTicksAtTime(time);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GT"])(ticks, this.time)) {
            // the event is not being scheduled from the beginning and should be offset
            this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;
        }
        this._currentId = this._createEvent();
        this._nextTick += this._interval;
        this._nextId = this._createEvent();
    }
    /**
     * Clean up
     */ dispose() {
        super.dispose();
        this.transport.clear(this._currentId);
        this.transport.clear(this._nextId);
        this.transport.off("start", this._boundRestart);
        this.transport.off("loopStart", this._boundRestart);
        this.transport.off("ticks", this._boundRestart);
        return this;
    }
} //# sourceMappingURL=TransportRepeatEvent.js.map
}),
"[project]/node_modules/tone/build/esm/core/clock/Transport.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransportClass",
    ()=>TransportClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TimelineValue$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TimelineValue.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$signal$2f$Pow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/signal/Pow.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ContextInitialization.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Gain.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneWithContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$IntervalTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/IntervalTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Clock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/Clock.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TransportEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportRepeatEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class TransportClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"] {
    constructor(){
        const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"])(TransportClass.getDefaults(), arguments);
        super(options);
        this.name = "Transport";
        //-------------------------------------
        // 	LOOPING
        //-------------------------------------
        /**
         * If the transport loops or not.
         */ this._loop = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TimelineValue$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimelineValue"](false);
        /**
         * The loop start position in ticks
         */ this._loopStart = 0;
        /**
         * The loop end position in ticks
         */ this._loopEnd = 0;
        //-------------------------------------
        // 	TIMELINE EVENTS
        //-------------------------------------
        /**
         * All the events in an object to keep track by ID
         */ this._scheduledEvents = {};
        /**
         * The scheduled events.
         */ this._timeline = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"]();
        /**
         * Repeated events
         */ this._repeatedEvents = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$IntervalTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntervalTimeline"]();
        /**
         * All of the synced Signals
         */ this._syncedSignals = [];
        /**
         * The swing amount
         */ this._swingAmount = 0;
        // CLOCK/TEMPO
        this._ppq = options.ppq;
        this._clock = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Clock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clock"]({
            callback: this._processTick.bind(this),
            context: this.context,
            frequency: 0,
            units: "bpm"
        });
        this._bindClockEvents();
        this.bpm = this._clock.frequency;
        this._clock.frequency.multiplier = options.ppq;
        this.bpm.setValueAtTime(options.bpm, 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOnly"])(this, "bpm");
        this._timeSignature = options.timeSignature;
        // SWING
        this._swingTicks = options.ppq / 2; // 8n
    }
    static getDefaults() {
        return Object.assign(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneWithContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneWithContext"].getDefaults(), {
            bpm: 120,
            loopEnd: "4m",
            loopStart: 0,
            ppq: 192,
            swing: 0,
            swingSubdivision: "8n",
            timeSignature: 4
        });
    }
    //-------------------------------------
    // 	TICKS
    //-------------------------------------
    /**
     * called on every tick
     * @param  tickTime clock relative tick time
     */ _processTick(tickTime, ticks) {
        // do the loop test
        if (this._loop.get(tickTime)) {
            if (ticks >= this._loopEnd) {
                this.emit("loopEnd", tickTime);
                this._clock.setTicksAtTime(this._loopStart, tickTime);
                ticks = this._loopStart;
                this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
                this.emit("loop", tickTime);
            }
        }
        // handle swing
        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat
        ticks % (this._swingTicks * 2) !== 0) {
            // add some swing
            const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
            const amount = Math.sin(progress * Math.PI) * this._swingAmount;
            tickTime += new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
        }
        // invoke the timeline events scheduled on this tick
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enterScheduledCallback"])(true);
        this._timeline.forEachAtTime(ticks, (event)=>event.invoke(tickTime));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enterScheduledCallback"])(false);
    }
    //-------------------------------------
    // 	SCHEDULABLE EVENTS
    //-------------------------------------
    /**
     * Schedule an event along the timeline.
     * @param callback The callback to be invoked at the time.
     * @param time The time to invoke the callback at.
     * @return The id of the event which can be used for canceling the event.
     * @example
     * // schedule an event on the 16th measure
     * Tone.getTransport().schedule((time) => {
     * 	// invoked on measure 16
     * 	console.log("measure 16!");
     * }, "16:0:0");
     */ schedule(callback, time) {
        const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportEvent"](this, {
            callback,
            time: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"](this.context, time).toTicks()
        });
        return this._addEvent(event, this._timeline);
    }
    /**
     * Schedule a repeated event along the timeline. The event will fire
     * at the `interval` starting at the `startTime` and for the specified
     * `duration`.
     * @param  callback   The callback to invoke.
     * @param  interval   The duration between successive callbacks. Must be a positive number.
     * @param  startTime  When along the timeline the events should start being invoked.
     * @param  duration How long the event should repeat.
     * @return  The ID of the scheduled event. Use this to cancel the event.
     * @example
     * const osc = new Tone.Oscillator().toDestination().start();
     * // a callback invoked every eighth note after the first measure
     * Tone.getTransport().scheduleRepeat((time) => {
     * 	osc.start(time).stop(time + 0.1);
     * }, "8n", "1m");
     */ scheduleRepeat(callback, interval, startTime, duration = Infinity) {
        const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportRepeatEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportRepeatEvent"](this, {
            callback,
            duration: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"](this.context, duration).toTicks(),
            interval: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"](this.context, interval).toTicks(),
            time: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"](this.context, startTime).toTicks()
        });
        // kick it off if the Transport is started
        // @ts-ignore
        return this._addEvent(event, this._repeatedEvents);
    }
    /**
     * Schedule an event that will be removed after it is invoked.
     * @param callback The callback to invoke once.
     * @param time The time the callback should be invoked.
     * @returns The ID of the scheduled event.
     */ scheduleOnce(callback, time) {
        const event = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$TransportEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportEvent"](this, {
            callback,
            once: true,
            time: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"](this.context, time).toTicks()
        });
        return this._addEvent(event, this._timeline);
    }
    /**
     * Clear the passed in event id from the timeline
     * @param eventId The id of the event.
     */ clear(eventId) {
        if (this._scheduledEvents.hasOwnProperty(eventId)) {
            const item = this._scheduledEvents[eventId.toString()];
            item.timeline.remove(item.event);
            item.event.dispose();
            delete this._scheduledEvents[eventId.toString()];
        }
        return this;
    }
    /**
     * Add an event to the correct timeline. Keep track of the
     * timeline it was added to.
     * @returns the event id which was just added
     */ _addEvent(event, timeline) {
        this._scheduledEvents[event.id.toString()] = {
            event,
            timeline
        };
        timeline.add(event);
        return event.id;
    }
    /**
     * Remove scheduled events from the timeline after
     * the given time. Repeated events will be removed
     * if their startTime is after the given time
     * @param after Clear all events after this time.
     */ cancel(after = 0) {
        const computedAfter = this.toTicks(after);
        this._timeline.forEachFrom(computedAfter, (event)=>this.clear(event.id));
        this._repeatedEvents.forEachFrom(computedAfter, (event)=>this.clear(event.id));
        return this;
    }
    //-------------------------------------
    // 	START/STOP/PAUSE
    //-------------------------------------
    /**
     * Bind start/stop/pause events from the clock and emit them.
     */ _bindClockEvents() {
        this._clock.on("start", (time, offset)=>{
            offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, offset).toSeconds();
            this.emit("start", time, offset);
        });
        this._clock.on("stop", (time)=>{
            this.emit("stop", time);
        });
        this._clock.on("pause", (time)=>{
            this.emit("pause", time);
        });
    }
    /**
     * Returns the playback state of the source, either "started", "stopped", or "paused"
     */ get state() {
        return this._clock.getStateAtTime(this.now());
    }
    /**
     * Start the transport and all sources synced to the transport.
     * @param  time The time when the transport should start.
     * @param  offset The timeline offset to start the transport.
     * @example
     * // start the transport in one second starting at beginning of the 5th measure.
     * Tone.getTransport().start("+1", "4:0:0");
     */ start(time, offset) {
        // start the context
        this.context.resume();
        let offsetTicks;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(offset)) {
            offsetTicks = this.toTicks(offset);
        }
        // start the clock
        this._clock.start(time, offsetTicks);
        return this;
    }
    /**
     * Stop the transport and all sources synced to the transport.
     * @param time The time when the transport should stop.
     * @example
     * Tone.getTransport().stop();
     */ stop(time) {
        this._clock.stop(time);
        return this;
    }
    /**
     * Pause the transport and all sources synced to the transport.
     */ pause(time) {
        this._clock.pause(time);
        return this;
    }
    /**
     * Toggle the current state of the transport. If it is
     * started, it will stop it, otherwise it will start the Transport.
     * @param  time The time of the event
     */ toggle(time) {
        time = this.toSeconds(time);
        if (this._clock.getStateAtTime(time) !== "started") {
            this.start(time);
        } else {
            this.stop(time);
        }
        return this;
    }
    //-------------------------------------
    // 	SETTERS/GETTERS
    //-------------------------------------
    /**
     * The time signature as just the numerator over 4.
     * For example 4/4 would be just 4 and 6/8 would be 3.
     * @example
     * // common time
     * Tone.getTransport().timeSignature = 4;
     * // 7/8
     * Tone.getTransport().timeSignature = [7, 8];
     * // this will be reduced to a single number
     * Tone.getTransport().timeSignature; // returns 3.5
     */ get timeSignature() {
        return this._timeSignature;
    }
    set timeSignature(timeSig) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(timeSig)) {
            timeSig = timeSig[0] / timeSig[1] * 4;
        }
        this._timeSignature = timeSig;
    }
    /**
     * When the Transport.loop = true, this is the starting position of the loop.
     */ get loopStart() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"](this.context, this._loopStart, "i").toSeconds();
    }
    set loopStart(startPosition) {
        this._loopStart = this.toTicks(startPosition);
    }
    /**
     * When the Transport.loop = true, this is the ending position of the loop.
     */ get loopEnd() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"](this.context, this._loopEnd, "i").toSeconds();
    }
    set loopEnd(endPosition) {
        this._loopEnd = this.toTicks(endPosition);
    }
    /**
     * If the transport loops or not.
     */ get loop() {
        return this._loop.get(this.now());
    }
    set loop(loop) {
        this._loop.set(loop, this.now());
    }
    /**
     * Set the loop start and stop at the same time.
     * @example
     * // loop over the first measure
     * Tone.getTransport().setLoopPoints(0, "1m");
     * Tone.getTransport().loop = true;
     */ setLoopPoints(startPosition, endPosition) {
        this.loopStart = startPosition;
        this.loopEnd = endPosition;
        return this;
    }
    /**
     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
     */ get swing() {
        return this._swingAmount;
    }
    set swing(amount) {
        // scale the values to a normal range
        this._swingAmount = amount;
    }
    /**
     * Set the subdivision which the swing will be applied to.
     * The default value is an 8th note. Value must be less
     * than a quarter note.
     */ get swingSubdivision() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, this._swingTicks).toNotation();
    }
    set swingSubdivision(subdivision) {
        this._swingTicks = this.toTicks(subdivision);
    }
    /**
     * The Transport's position in Bars:Beats:Sixteenths.
     * Setting the value will jump to that position right away.
     */ get position() {
        const now = this.now();
        const ticks = this._clock.getTicksAtTime(now);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"](this.context, ticks).toBarsBeatsSixteenths();
    }
    set position(progress) {
        const ticks = this.toTicks(progress);
        this.ticks = ticks;
    }
    /**
     * The Transport's position in seconds.
     * Setting the value will jump to that position right away.
     */ get seconds() {
        return this._clock.seconds;
    }
    set seconds(s) {
        const now = this.now();
        const ticks = this._clock.frequency.timeToTicks(s, now);
        this.ticks = ticks;
    }
    /**
     * The Transport's loop position as a normalized value. Always
     * returns 0 if the Transport.loop = false.
     */ get progress() {
        if (this.loop) {
            const now = this.now();
            const ticks = this._clock.getTicksAtTime(now);
            return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
        } else {
            return 0;
        }
    }
    /**
     * The Transport's current tick position.
     */ get ticks() {
        return this._clock.ticks;
    }
    set ticks(t) {
        if (this._clock.ticks !== t) {
            const now = this.now();
            // stop everything synced to the transport
            if (this.state === "started") {
                const ticks = this._clock.getTicksAtTime(now);
                // schedule to start on the next tick, #573
                const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);
                const time = now + remainingTick;
                this.emit("stop", time);
                this._clock.setTicksAtTime(t, time);
                // restart it with the new time
                this.emit("start", time, this._clock.getSecondsAtTime(time));
            } else {
                this.emit("ticks", now);
                this._clock.setTicksAtTime(t, now);
            }
        }
    }
    /**
     * Get the clock's ticks at the given time.
     * @param  time  When to get the tick value
     * @return The tick value at the given time.
     */ getTicksAtTime(time) {
        return this._clock.getTicksAtTime(time);
    }
    /**
     * Return the elapsed seconds at the given time.
     * @param  time  When to get the elapsed seconds
     * @return  The number of elapsed seconds
     */ getSecondsAtTime(time) {
        return this._clock.getSecondsAtTime(time);
    }
    /**
     * Pulses Per Quarter note. This is the smallest resolution
     * the Transport timing supports. This should be set once
     * on initialization and not set again. Changing this value
     * after other objects have been created can cause problems.
     */ get PPQ() {
        return this._clock.frequency.multiplier;
    }
    set PPQ(ppq) {
        this._clock.frequency.multiplier = ppq;
    }
    //-------------------------------------
    // 	SYNCING
    //-------------------------------------
    /**
     * Returns the time aligned to the next subdivision
     * of the Transport. If the Transport is not started,
     * it will return 0.
     * Note: this will not work precisely during tempo ramps.
     * @param  subdivision  The subdivision to quantize to
     * @return  The context time of the next subdivision.
     * @example
     * // the transport must be started, otherwise returns 0
     * Tone.getTransport().start();
     * Tone.getTransport().nextSubdivision("4n");
     */ nextSubdivision(subdivision) {
        subdivision = this.toTicks(subdivision);
        if (this.state !== "started") {
            // if the transport's not started, return 0
            return 0;
        } else {
            const now = this.now();
            // the remainder of the current ticks and the subdivision
            const transportPos = this.getTicksAtTime(now);
            const remainingTicks = subdivision - transportPos % subdivision;
            return this._clock.nextTickTime(remainingTicks, now);
        }
    }
    /**
     * Attaches the signal to the tempo control signal so that
     * any changes in the tempo will change the signal in the same
     * ratio.
     *
     * @param signal
     * @param ratio Optionally pass in the ratio between the two signals.
     * 			Otherwise it will be computed based on their current values.
     */ syncSignal(signal, ratio) {
        const now = this.now();
        let source = this.bpm;
        let sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);
        let nodes = [];
        // If the signal is in the time domain, sync it to the reciprocal of
        // the tempo instead of the tempo.
        if (signal.units === "time") {
            // The input to Pow should be in the range [1 / 4096, 1], where
            // where 4096 is half of the buffer size of Pow's waveshaper.
            // Pick a scaling factor based on the initial tempo that ensures
            // that the initial input is in this range, while leaving room for
            // tempo changes.
            const scaleFactor = 1 / 64 / sourceValue;
            const scaleBefore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Gain"](scaleFactor);
            const reciprocal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$signal$2f$Pow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Pow"](-1);
            const scaleAfter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Gain"](scaleFactor);
            // @ts-ignore
            source.chain(scaleBefore, reciprocal, scaleAfter);
            source = scaleAfter;
            sourceValue = 1 / sourceValue;
            nodes = [
                scaleBefore,
                reciprocal,
                scaleAfter
            ];
        }
        if (!ratio) {
            // get the sync ratio
            if (signal.getValueAtTime(now) !== 0) {
                ratio = signal.getValueAtTime(now) / sourceValue;
            } else {
                ratio = 0;
            }
        }
        const ratioSignal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Gain"](ratio);
        // @ts-ignore
        source.connect(ratioSignal);
        // @ts-ignore
        ratioSignal.connect(signal._param);
        nodes.push(ratioSignal);
        this._syncedSignals.push({
            initial: signal.value,
            nodes: nodes,
            signal
        });
        signal.value = 0;
        return this;
    }
    /**
     * Unsyncs a previously synced signal from the transport's control.
     * @see {@link syncSignal}.
     */ unsyncSignal(signal) {
        for(let i = this._syncedSignals.length - 1; i >= 0; i--){
            const syncedSignal = this._syncedSignals[i];
            if (syncedSignal.signal === signal) {
                syncedSignal.nodes.forEach((node)=>node.dispose());
                syncedSignal.signal.value = syncedSignal.initial;
                this._syncedSignals.splice(i, 1);
            }
        }
        return this;
    }
    /**
     * Clean up.
     */ dispose() {
        super.dispose();
        this._clock.dispose();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["writable"])(this, "bpm");
        this._timeline.dispose();
        this._repeatedEvents.dispose();
        return this;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Emitter"].mixin(TransportClass);
//-------------------------------------
// 	INITIALIZATION
//-------------------------------------
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextInit"])((context)=>{
    context.transport = new TransportClass({
        context
    });
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ContextInitialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onContextClose"])((context)=>{
    context.transport.dispose();
}); //# sourceMappingURL=Transport.js.map
}),
"[project]/node_modules/tone/build/esm/core/util/Decorator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "range",
    ()=>range,
    "timeRange",
    ()=>timeRange
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
;
function range(min, max = Infinity) {
    const valueMap = new WeakMap();
    return function(target, propertyKey) {
        Reflect.defineProperty(target, propertyKey, {
            configurable: true,
            enumerable: true,
            get: function() {
                return valueMap.get(this);
            },
            set: function(newValue) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertRange"])(newValue, min, max);
                valueMap.set(this, newValue);
            }
        });
    };
}
function timeRange(min, max = Infinity) {
    const valueMap = new WeakMap();
    return function(target, propertyKey) {
        Reflect.defineProperty(target, propertyKey, {
            configurable: true,
            enumerable: true,
            get: function() {
                return valueMap.get(this);
            },
            set: function(newValue) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertRange"])(this.toSeconds(newValue), min, max);
                valueMap.set(this, newValue);
            }
        });
    };
} //# sourceMappingURL=Decorator.js.map
}),
"[project]/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * All of the classes or functions which are loaded into the AudioWorkletGlobalScope
 */ __turbopack_context__.s([
    "addToWorklet",
    ()=>addToWorklet,
    "getWorkletGlobalScope",
    ()=>getWorkletGlobalScope,
    "registerProcessor",
    ()=>registerProcessor
]);
const workletContext = new Set();
function addToWorklet(classOrFunction) {
    workletContext.add(classOrFunction);
}
function registerProcessor(name, classDesc) {
    const processor = /* javascript */ `registerProcessor("${name}", ${classDesc})`;
    workletContext.add(processor);
}
function getWorkletGlobalScope() {
    return Array.from(workletContext).join("\n");
} //# sourceMappingURL=WorkletGlobalScope.js.map
}),
"[project]/node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ToneAudioWorklet",
    ()=>ToneAudioWorklet
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js [app-client] (ecmascript)");
;
;
;
class ToneAudioWorklet extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"] {
    constructor(options){
        super(options);
        this.name = "ToneAudioWorklet";
        /**
         * The constructor options for the node
         */ this.workletOptions = {};
        /**
         * Callback which is invoked when there is an error in the processing
         */ this.onprocessorerror = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noOp"];
        const blobUrl = URL.createObjectURL(new Blob([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWorkletGlobalScope"])()
        ], {
            type: "text/javascript"
        }));
        const name = this._audioWorkletName();
        this._dummyGain = this.context.createGain();
        this._dummyParam = this._dummyGain.gain;
        // Register the processor
        this.context.addAudioWorkletModule(blobUrl).then(()=>{
            // create the worklet when it's read
            if (!this.disposed) {
                this._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);
                this._worklet.onprocessorerror = this.onprocessorerror.bind(this);
                this.onReady(this._worklet);
            }
        });
    }
    dispose() {
        super.dispose();
        this._dummyGain.disconnect();
        if (this._worklet) {
            this._worklet.port.postMessage("dispose");
            this._worklet.disconnect();
        }
        return this;
    }
} //# sourceMappingURL=ToneAudioWorklet.js.map
}),
"[project]/node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js [app-client] (ecmascript)");
;
const toneAudioWorkletProcessor = /* javascript */ `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addToWorklet"])(toneAudioWorkletProcessor); //# sourceMappingURL=ToneAudioWorkletProcessor.worklet.js.map
}),
"[project]/node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "singleIOProcess",
    ()=>singleIOProcess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$ToneAudioWorkletProcessor$2e$worklet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js [app-client] (ecmascript)");
;
;
const singleIOProcess = /* javascript */ `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addToWorklet"])(singleIOProcess); //# sourceMappingURL=SingleIOProcessor.worklet.js.map
}),
"[project]/node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js [app-client] (ecmascript)");
;
const delayLine = /* javascript */ `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$worklet$2f$WorkletGlobalScope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addToWorklet"])(delayLine); //# sourceMappingURL=DelayLine.worklet.js.map
}),
"[project]/node_modules/tone/build/esm/core/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseContext",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseContext"],
    "Clock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Clock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clock"],
    "Context",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Context"],
    "Delay",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Delay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delay"],
    "Emitter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Emitter"],
    "Frequency",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Frequency"],
    "FrequencyClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrequencyClass"],
    "Gain",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Gain"],
    "IntervalTimeline",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$IntervalTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntervalTimeline"],
    "Midi",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Midi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Midi"],
    "MidiClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Midi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MidiClass"],
    "Offline",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Offline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Offline"],
    "OfflineContext",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OfflineContext"],
    "Param",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Param"],
    "StateTimeline",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StateTimeline"],
    "Ticks",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ticks"],
    "TicksClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TicksClass"],
    "Time",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Time"],
    "TimeClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeClass"],
    "Timeline",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Timeline"],
    "ToneAudioBuffer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffer"],
    "ToneAudioBuffers",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioBuffers"],
    "ToneAudioNode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToneAudioNode"],
    "TransportTime",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTime"],
    "TransportTimeClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransportTimeClass"],
    "Unit",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Units$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "connect",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"],
    "connectSeries",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connectSeries"],
    "dbToGain",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dbToGain"],
    "debug",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "defaultArg",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultArg"],
    "disconnect",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disconnect"],
    "fanIn",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fanIn"],
    "ftom",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ftom"],
    "gainToDb",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gainToDb"],
    "intervalToFrequencyRatio",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intervalToFrequencyRatio"],
    "isArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"],
    "isBoolean",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBoolean"],
    "isDefined",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"],
    "isFunction",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"],
    "isNote",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNote"],
    "isNumber",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"],
    "isObject",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"],
    "isString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"],
    "isUndef",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUndef"],
    "mtof",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mtof"],
    "optionsFromArguments",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsFromArguments"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$clock$2f$Clock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/clock/Clock.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$BaseContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/BaseContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Delay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Delay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Gain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Gain.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Offline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Offline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$OfflineContext$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/OfflineContext.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$Param$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/Param.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioBuffers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$context$2f$ToneAudioNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/context/ToneAudioNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Frequency$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Frequency.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Midi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Midi.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$TransportTime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/TransportTime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Emitter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Emitter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$IntervalTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/IntervalTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$StateTimeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/StateTimeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Timeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Timeline.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$TypeCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/TypeCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$type$2f$Units$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/type/Units.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tone$2f$build$2f$esm$2f$core$2f$util$2f$Debug$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tone/build/esm/core/util/Debug.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_tone_build_esm_core_aa283d39._.js.map